{"content": "# GIS QuerySet API Reference\n\n## Spatial Lookups\n\nThe spatial lookups in this section are available for [`GeometryField`](model-api.md#django.contrib.gis.db.models.GeometryField)\nand [`RasterField`](model-api.md#django.contrib.gis.db.models.RasterField).\n\nFor an introduction, see the [spatial lookups introduction](db-api.md#spatial-lookups-intro). For an overview of what lookups are\ncompatible with a particular spatial backend", "source_file_id": "django__5_2__ref__contrib__gis__geoquerysets.html", "headings": ["GIS QuerySet API Reference"], "order": 0, "level": 1, "tokens": 7, "code_languages": ["python"], "links_out": [], "id": "43eaf033d38d46ca", "char_count": 430}
{"content": "# GIS QuerySet API Reference\n\n## Spatial Lookups\n\nThe spatial lookups in this section are available for [`GeometryField`](model-api.md#django.contrib.gis.db.models.GeometryField)\nand [`RasterField`](model-api.md#django.contrib.gis.db.models.RasterField).\n\nFor an introduction, see the [spatial lookups introduction](db-api.md#spatial-lookups-intro). For an overview of what lookups are\ncompatible with a particular spatial backend, refer to the\n[spatial lookup compatibility table](db-api.md#spatial-lookup-compatibility).\n\n### Lookups with rasters\n\nAll examples in the reference below are given for geometry fields and inputs,\nbut the lookups can be used the same way with rasters on both sides. Whenever\na lookup doesn\u2019t support raster input, the input is automatically\nconverted to a geometry where necessary using the [ST\\_Polygon](https://postgis.net/docs/RT_ST_Polygon.md) function. See also the\n[introduction to raste", "source_file_id": "django__5_2__ref__contrib__gis__geoquerysets.html", "headings": ["GIS QuerySet API Reference", "Spatial Lookups"], "order": 1, "level": 2, "tokens": 123, "code_languages": ["python"], "links_out": [{"text": "`GeometryField`", "href": "model-api.md#django.contrib.gis.db.models.GeometryField"}, {"text": "`RasterField`", "href": "model-api.md#django.contrib.gis.db.models.RasterField"}, {"text": "spatial lookups introduction", "href": "db-api.md#spatial-lookups-intro"}, {"text": "spatial lookup compatibility table", "href": "db-api.md#spatial-lookup-compatibility"}], "id": "84ef7f6360f6c653", "char_count": 924}
{"content": "model-api.md#django.contrib.gis.db.models.GeometryField)\nand [`RasterField`](model-api.md#django.contrib.gis.db.models.RasterField).\n\nFor an introduction, see the [spatial lookups introduction](db-api.md#spatial-lookups-intro). For an overview of what lookups are\ncompatible with a particular spatial backend, refer to the\n[spatial lookup compatibility table](db-api.md#spatial-lookup-compatibility).\n\n### Lookups with rasters\n\nAll examples in the reference below are given for geometry fields and inputs,\nbut the lookups can be used the same way with rasters on both sides. Whenever\na lookup doesn\u2019t support raster input, the input is automatically\nconverted to a geometry where necessary using the [ST\\_Polygon](https://postgis.net/docs/RT_ST_Polygon.md) function. See also the\n[introduction to raster lookups](db-api.md#spatial-lookup-raster).\n\nThe database operators used by the lookups can be divided into three categories:\n\n- Native raster support `N`: the operator accepts rasters natively on both\n  sides of the lookup, and raster input can be mixed with geometry inputs.\n- Bilateral raster support `B`: the operator supports rasters only if both\n  sides of the lookup receive raster inputs. Raster data is automatically\n  converted to geometries for mixed lookups.\n- Geometry conversion support `C`. The lookup does not have native raster\n  support, all raster data is automatically converted to geometries.\n\nThe examples below show the SQL equivalent for the lookups in the different\ntypes of raster support. The same pattern applies to all spatial lookups.\n\n| Case | Lookup | SQL Equivalent |\n| --- | --- | --- |\n| N, B | `rast__contains=rst` | `ST_Contains(rast, rst)` |\n| N, B | `rast__1__contains=(rst, 2)` | `ST_Contains(rast, 1, rst, 2)` |\n| B, C | `rast__contains=geom` | `ST_Contains(ST_Polygon(rast), geom)` |\n| B, C | `rast__1__contains=geom` | `ST_Contains(ST_Polygon(rast, 1), geom)` |\n| B, C | `poly__contains=rst` | `ST_Contains(poly, ST_Polygon(rst))` |\n| B, C | `poly__contains=(rst, 1)` | `ST_Contains(poly, ST_Polygon(rst, 1))` |\n| C | `rast__crosses=rst` | `ST_Crosses(ST_Polygon(rast), ST_Polygon(rst))` |\n| C | `rast__1__crosses=(rst, 2)` | `ST_Crosses(ST_Polygon(rast, 1), ST_Polygon(rst, 2))` |\n| C | `rast__crosses=geom` | `ST_Crosses(ST_Polygon(rast), geom)` |\n| C | `poly__crosses=rst` | `ST_Crosses(poly, ST_Polygon(rst))` |\n\nSpatial lookups with rasters are only supported for PostGIS backends\n(denominated as PGRaster in this section).\n\n### `bbcontains`\n\n*Availability*: [PostGIS](https://postgis.net/docs/ST_Geometry_Contain.md),\nMariaDB, MySQL, SpatiaLite, PGRaster (Native)\n\nTests if the geometry or raster field\u2019s bounding box completely contains the\nlookup geometry\u2019s bounding box.\n\nExample:\n\n```python\nZipcode.objects.filter(poly__bbcontains=geom)\n```\n\n| Backend | SQL Equivalent |\n| --- | --- |\n| PostGIS | `poly ~ geom` |\n| Maria", "source_file_id": "django__5_2__ref__contrib__gis__geoquerysets.html", "headings": ["GIS QuerySet API Reference", "Spatial Lookups", "Lookups with rasters"], "order": 2, "level": 3, "tokens": 518, "code_languages": [], "links_out": [{"text": "ST\\_Polygon", "href": "https://postgis.net/docs/RT_ST_Polygon.md"}, {"text": "introduction to raster lookups", "href": "db-api.md#spatial-lookup-raster"}], "id": "868077d232ccb027", "char_count": 2876}
{"content": "sses=rst` | `ST_Crosses(ST_Polygon(rast), ST_Polygon(rst))` |\n| C | `rast__1__crosses=(rst, 2)` | `ST_Crosses(ST_Polygon(rast, 1), ST_Polygon(rst, 2))` |\n| C | `rast__crosses=geom` | `ST_Crosses(ST_Polygon(rast), geom)` |\n| C | `poly__crosses=rst` | `ST_Crosses(poly, ST_Polygon(rst))` |\n\nSpatial lookups with rasters are only supported for PostGIS backends\n(denominated as PGRaster in this section).\n\n### `bbcontains`\n\n*Availability*: [PostGIS](https://postgis.net/docs/ST_Geometry_Contain.md),\nMariaDB, MySQL, SpatiaLite, PGRaster (Native)\n\nTests if the geometry or raster field\u2019s bounding box completely contains the\nlookup geometry\u2019s bounding box.\n\nExample:\n\n```python\nZipcode.objects.filter(poly__bbcontains=geom)\n```\n\n| Backend | SQL Equivalent |\n| --- | --- |\n| PostGIS | `poly ~ geom` |\n| MariaDB | `MBRContains(poly, geom)` |\n| MySQL | `MBRContains(poly, geom)` |\n| SpatiaLite | `MbrContains(poly, geom)` |\n\n### `bboverlaps`\n\n*Availability*: [PostGIS](https://postgis.net/docs/geometry_overlaps.md),\nMariaDB, MySQL, SpatiaLite, PGRaster (Native)\n\nTests if the geometry field\u2019s bounding box overlaps the lookup geometry\u2019s\nbounding box.\n\nExample:\n\n```python\nZipcode.objects.filter(poly__bboverlaps=geom)\n```\n\n| Backend | SQL Equivalent |\n| --- | --- |\n| PostGIS | `poly && geom` |\n| MariaDB | `MBROverlaps(poly, ", "source_file_id": "django__5_2__ref__contrib__gis__geoquerysets.html", "headings": ["GIS QuerySet API Reference", "Spatial Lookups", "`bbcontains`"], "order": 3, "level": 3, "tokens": 128, "code_languages": ["python"], "links_out": [{"text": "PostGIS", "href": "https://postgis.net/docs/ST_Geometry_Contain.md"}], "id": "5327e7e0ab9a43dd", "char_count": 1319}
{"content": "tiaLite, PGRaster (Native)\n\nTests if the geometry or raster field\u2019s bounding box completely contains the\nlookup geometry\u2019s bounding box.\n\nExample:\n\n```python\nZipcode.objects.filter(poly__bbcontains=geom)\n```\n\n| Backend | SQL Equivalent |\n| --- | --- |\n| PostGIS | `poly ~ geom` |\n| MariaDB | `MBRContains(poly, geom)` |\n| MySQL | `MBRContains(poly, geom)` |\n| SpatiaLite | `MbrContains(poly, geom)` |\n\n### `bboverlaps`\n\n*Availability*: [PostGIS](https://postgis.net/docs/geometry_overlaps.md),\nMariaDB, MySQL, SpatiaLite, PGRaster (Native)\n\nTests if the geometry field\u2019s bounding box overlaps the lookup geometry\u2019s\nbounding box.\n\nExample:\n\n```python\nZipcode.objects.filter(poly__bboverlaps=geom)\n```\n\n| Backend | SQL Equivalent |\n| --- | --- |\n| PostGIS | `poly && geom` |\n| MariaDB | `MBROverlaps(poly, geom)` |\n| MySQL | `MBROverlaps(poly, geom)` |\n| SpatiaLite | `MbrOverlaps(poly, geom)` |\n\n### `contained`\n\n*Availability*: [PostGIS](https://postgis.net/docs/ST_Geometry_Contained.md),\nMariaDB, MySQL, SpatiaLite, PGRaster (Native)\n\nTests if the geometry field\u2019s bounding box is completely contained by the\nlookup geometry\u2019s bounding box.\n\nExample:\n\n```python\nZipcode.objects.filter(poly__contained=geom)\n```\n\n| Backend | SQL Equivalent |\n| --- | --- |\n| PostGIS | `poly @ geom` |\n| MariaDB ", "source_file_id": "django__5_2__ref__contrib__gis__geoquerysets.html", "headings": ["GIS QuerySet API Reference", "Spatial Lookups", "`bboverlaps`"], "order": 4, "level": 3, "tokens": 122, "code_languages": ["python"], "links_out": [{"text": "PostGIS", "href": "https://postgis.net/docs/geometry_overlaps.md"}], "id": "26a0687ecb5e5b34", "char_count": 1295}
{"content": "),\nMariaDB, MySQL, SpatiaLite, PGRaster (Native)\n\nTests if the geometry field\u2019s bounding box overlaps the lookup geometry\u2019s\nbounding box.\n\nExample:\n\n```python\nZipcode.objects.filter(poly__bboverlaps=geom)\n```\n\n| Backend | SQL Equivalent |\n| --- | --- |\n| PostGIS | `poly && geom` |\n| MariaDB | `MBROverlaps(poly, geom)` |\n| MySQL | `MBROverlaps(poly, geom)` |\n| SpatiaLite | `MbrOverlaps(poly, geom)` |\n\n### `contained`\n\n*Availability*: [PostGIS](https://postgis.net/docs/ST_Geometry_Contained.md),\nMariaDB, MySQL, SpatiaLite, PGRaster (Native)\n\nTests if the geometry field\u2019s bounding box is completely contained by the\nlookup geometry\u2019s bounding box.\n\nExample:\n\n```python\nZipcode.objects.filter(poly__contained=geom)\n```\n\n| Backend | SQL Equivalent |\n| --- | --- |\n| PostGIS | `poly @ geom` |\n| MariaDB | `MBRWithin(poly, geom)` |\n| MySQL | `MBRWithin(poly, geom)` |\n| SpatiaLite | `MbrWithin(poly, geom)` |\n\n### `contains`\n\n*Availability*: [PostGIS](https://postgis.net/docs/ST_Contains.md),\nOracle, MariaDB, MySQL, SpatiaLite, PGRaster (Bilateral)\n\nTests if the geometry field spatially contains the lookup geometry.\n\nExample:\n\n```python\nZipcode.objects.filter(poly__contains=geom)\n```\n\n| Backend | SQL Equivalent |\n| --- | --- |\n| PostGIS | `ST_Contains(poly, geom)` |\n| Oracle | `SDO_CONTAINS(poly, geom)`", "source_file_id": "django__5_2__ref__contrib__gis__geoquerysets.html", "headings": ["GIS QuerySet API Reference", "Spatial Lookups", "`contained`"], "order": 5, "level": 3, "tokens": 126, "code_languages": ["python"], "links_out": [{"text": "PostGIS", "href": "https://postgis.net/docs/ST_Geometry_Contained.md"}], "id": "57b6fc9ac468464d", "char_count": 1310}
{"content": "MySQL, SpatiaLite, PGRaster (Native)\n\nTests if the geometry field\u2019s bounding box is completely contained by the\nlookup geometry\u2019s bounding box.\n\nExample:\n\n```python\nZipcode.objects.filter(poly__contained=geom)\n```\n\n| Backend | SQL Equivalent |\n| --- | --- |\n| PostGIS | `poly @ geom` |\n| MariaDB | `MBRWithin(poly, geom)` |\n| MySQL | `MBRWithin(poly, geom)` |\n| SpatiaLite | `MbrWithin(poly, geom)` |\n\n### `contains`\n\n*Availability*: [PostGIS](https://postgis.net/docs/ST_Contains.md),\nOracle, MariaDB, MySQL, SpatiaLite, PGRaster (Bilateral)\n\nTests if the geometry field spatially contains the lookup geometry.\n\nExample:\n\n```python\nZipcode.objects.filter(poly__contains=geom)\n```\n\n| Backend | SQL Equivalent |\n| --- | --- |\n| PostGIS | `ST_Contains(poly, geom)` |\n| Oracle | `SDO_CONTAINS(poly, geom)` |\n| MariaDB | `ST_Contains(poly, geom)` |\n| MySQL | `ST_Contains(poly, geom)` |\n| SpatiaLite | `Contains(poly, geom)` |\n\n### `contains_properly`\n\n*Availability*: [PostGIS](https://postgis.net/docs/ST_ContainsProperly.md),\nPGRaster (Bilateral)\n\nReturns true if the lookup geometry intersects the interior of the\ngeometry field, but not the boundary (or exterior).\n\nExample:\n\n```python\nZipcode.objects.filter(poly__contains_properly=geom)\n```\n\n| Backend | SQL Equivalent |\n| --- | --- |\n| PostGIS | `ST_ContainsProperly(poly,", "source_file_id": "django__5_2__ref__contrib__gis__geoquerysets.html", "headings": ["GIS QuerySet API Reference", "Spatial Lookups", "`contains`"], "order": 6, "level": 3, "tokens": 130, "code_languages": ["python"], "links_out": [{"text": "PostGIS", "href": "https://postgis.net/docs/ST_Contains.md"}], "id": "f53b88062ee19045", "char_count": 1326}
{"content": "PGRaster (Bilateral)\n\nTests if the geometry field spatially contains the lookup geometry.\n\nExample:\n\n```python\nZipcode.objects.filter(poly__contains=geom)\n```\n\n| Backend | SQL Equivalent |\n| --- | --- |\n| PostGIS | `ST_Contains(poly, geom)` |\n| Oracle | `SDO_CONTAINS(poly, geom)` |\n| MariaDB | `ST_Contains(poly, geom)` |\n| MySQL | `ST_Contains(poly, geom)` |\n| SpatiaLite | `Contains(poly, geom)` |\n\n### `contains_properly`\n\n*Availability*: [PostGIS](https://postgis.net/docs/ST_ContainsProperly.md),\nPGRaster (Bilateral)\n\nReturns true if the lookup geometry intersects the interior of the\ngeometry field, but not the boundary (or exterior).\n\nExample:\n\n```python\nZipcode.objects.filter(poly__contains_properly=geom)\n```\n\n| Backend | SQL Equivalent |\n| --- | --- |\n| PostGIS | `ST_ContainsProperly(poly, geom)` |\n\n### `coveredby`\n\n*Availability*: [PostGIS](https://postgis.net/docs/ST_CoveredBy.md),\nOracle, MySQL, PGRaster (Bilateral), SpatiaLite\n\nTests if no point in the geometry field is outside the lookup geometry.\n[[3]](#fncovers)\n\nExample:\n\n```python\nZipcode.objects.filter(poly__coveredby=geom)\n```\n\n| Backend | SQL Equivalent |\n| --- | --- |\n| PostGIS | `ST_CoveredBy(poly, geom)` |\n| Oracle | `SDO_COVERE", "source_file_id": "django__5_2__ref__contrib__gis__geoquerysets.html", "headings": ["GIS QuerySet API Reference", "Spatial Lookups", "`contains_properly`"], "order": 7, "level": 3, "tokens": 102, "code_languages": ["python"], "links_out": [{"text": "PostGIS", "href": "https://postgis.net/docs/ST_ContainsProperly.md"}], "id": "a104af7cf80d48fe", "char_count": 1216}
{"content": "ains_properly`\n\n*Availability*: [PostGIS](https://postgis.net/docs/ST_ContainsProperly.md),\nPGRaster (Bilateral)\n\nReturns true if the lookup geometry intersects the interior of the\ngeometry field, but not the boundary (or exterior).\n\nExample:\n\n```python\nZipcode.objects.filter(poly__contains_properly=geom)\n```\n\n| Backend | SQL Equivalent |\n| --- | --- |\n| PostGIS | `ST_ContainsProperly(poly, geom)` |\n\n### `coveredby`\n\n*Availability*: [PostGIS](https://postgis.net/docs/ST_CoveredBy.md),\nOracle, MySQL, PGRaster (Bilateral), SpatiaLite\n\nTests if no point in the geometry field is outside the lookup geometry.\n[[3]](#fncovers)\n\nExample:\n\n```python\nZipcode.objects.filter(poly__coveredby=geom)\n```\n\n| Backend | SQL Equivalent |\n| --- | --- |\n| PostGIS | `ST_CoveredBy(poly, geom)` |\n| Oracle | `SDO_COVEREDBY(poly, geom)` |\n| MySQL | `MBRCoveredBy(poly, geom)` |\n| SpatiaLite | `CoveredBy(poly, geom)` |\n\n> **Changed in Django 5.2:**\n>\n> MySQL support was added.\n\n### `covers`\n\n*Availability*: [PostGIS](https://postgis.net/docs/ST_Covers.md),\nOracle, MySQL, PGRaster (Bilateral), SpatiaLite\n\nTests if no point in the lookup geometry is outside the geometry field.\n[[3]](#fncovers)\n\nExample:\n\n```python\nZipcode.objects.filter(poly__covers=geom)\n```\n\n| Backend | SQL Equivalent |\n| --- | --- |\n| PostGIS | `ST_Covers(poly, geom)` |\n| Oracle | `SDO_COVERS(poly, geom", "source_file_id": "django__5_2__ref__contrib__gis__geoquerysets.html", "headings": ["GIS QuerySet API Reference", "Spatial Lookups", "`coveredby`"], "order": 8, "level": 3, "tokens": 139, "code_languages": ["python"], "links_out": [{"text": "PostGIS", "href": "https://postgis.net/docs/ST_CoveredBy.md"}], "id": "b1ae865bf20deba5", "char_count": 1364}
{"content": "he geometry field is outside the lookup geometry.\n[[3]](#fncovers)\n\nExample:\n\n```python\nZipcode.objects.filter(poly__coveredby=geom)\n```\n\n| Backend | SQL Equivalent |\n| --- | --- |\n| PostGIS | `ST_CoveredBy(poly, geom)` |\n| Oracle | `SDO_COVEREDBY(poly, geom)` |\n| MySQL | `MBRCoveredBy(poly, geom)` |\n| SpatiaLite | `CoveredBy(poly, geom)` |\n\n> **Changed in Django 5.2:**\n>\n> MySQL support was added.\n\n### `covers`\n\n*Availability*: [PostGIS](https://postgis.net/docs/ST_Covers.md),\nOracle, MySQL, PGRaster (Bilateral), SpatiaLite\n\nTests if no point in the lookup geometry is outside the geometry field.\n[[3]](#fncovers)\n\nExample:\n\n```python\nZipcode.objects.filter(poly__covers=geom)\n```\n\n| Backend | SQL Equivalent |\n| --- | --- |\n| PostGIS | `ST_Covers(poly, geom)` |\n| Oracle | `SDO_COVERS(poly, geom)` |\n| MySQL | `MBRCovers(poly, geom)` |\n| SpatiaLite | `Covers(poly, geom)` |\n\n> **Changed in Django 5.2:**\n>\n> MySQL support was added.\n\n### `crosses`\n\n*Availability*: [PostGIS](https://postgis.net/docs/ST_Crosses.md),\nMariaDB, MySQL, SpatiaLite, PGRaster (Conversion)\n\nTests if the geometry field spatially crosses the lookup geometry.\n\nExample:\n\n```python\nZipcode.objects.filter(poly__crosses=geom)\n```\n\n| Backend | SQL Equivalent |\n| --- | --- |\n| PostGIS | `ST_Crosses(poly, geom)` |\n| MariaDB | `ST_Crosses(poly, geom)` |\n| MySQL | ", "source_file_id": "django__5_2__ref__contrib__gis__geoquerysets.html", "headings": ["GIS QuerySet API Reference", "Spatial Lookups", "`covers`"], "order": 9, "level": 3, "tokens": 134, "code_languages": ["python"], "links_out": [{"text": "PostGIS", "href": "https://postgis.net/docs/ST_Covers.md"}], "id": "616b1a4cb0bcd39c", "char_count": 1342}
{"content": " no point in the lookup geometry is outside the geometry field.\n[[3]](#fncovers)\n\nExample:\n\n```python\nZipcode.objects.filter(poly__covers=geom)\n```\n\n| Backend | SQL Equivalent |\n| --- | --- |\n| PostGIS | `ST_Covers(poly, geom)` |\n| Oracle | `SDO_COVERS(poly, geom)` |\n| MySQL | `MBRCovers(poly, geom)` |\n| SpatiaLite | `Covers(poly, geom)` |\n\n> **Changed in Django 5.2:**\n>\n> MySQL support was added.\n\n### `crosses`\n\n*Availability*: [PostGIS](https://postgis.net/docs/ST_Crosses.md),\nMariaDB, MySQL, SpatiaLite, PGRaster (Conversion)\n\nTests if the geometry field spatially crosses the lookup geometry.\n\nExample:\n\n```python\nZipcode.objects.filter(poly__crosses=geom)\n```\n\n| Backend | SQL Equivalent |\n| --- | --- |\n| PostGIS | `ST_Crosses(poly, geom)` |\n| MariaDB | `ST_Crosses(poly, geom)` |\n| MySQL | `ST_Crosses(poly, geom)` |\n| SpatiaLite | `Crosses(poly, geom)` |\n\n### `disjoint`\n\n*Availability*: [PostGIS](https://postgis.net/docs/ST_Disjoint.md),\nOracle, MariaDB, MySQL, SpatiaLite, PGRaster (Bilateral)\n\nTests if the geometry field is spatially disjoint from the lookup geometry.\n\nExample:\n\n```python\nZipcode.objects.filter(poly__disjoint=geom)\n```\n\n| Backend | SQL Equivalent |\n| --- | --- |\n| PostGIS | `ST_Disjoint(poly, geom)` |\n| Oracle | `SDO_GEOM.RELATE(p", "source_file_id": "django__5_2__ref__contrib__gis__geoquerysets.html", "headings": ["GIS QuerySet API Reference", "Spatial Lookups", "`crosses`"], "order": 10, "level": 3, "tokens": 116, "code_languages": ["python"], "links_out": [{"text": "PostGIS", "href": "https://postgis.net/docs/ST_Crosses.md"}], "id": "3ccf9f0e97a8bdf3", "char_count": 1269}
{"content": "/ST_Crosses.md),\nMariaDB, MySQL, SpatiaLite, PGRaster (Conversion)\n\nTests if the geometry field spatially crosses the lookup geometry.\n\nExample:\n\n```python\nZipcode.objects.filter(poly__crosses=geom)\n```\n\n| Backend | SQL Equivalent |\n| --- | --- |\n| PostGIS | `ST_Crosses(poly, geom)` |\n| MariaDB | `ST_Crosses(poly, geom)` |\n| MySQL | `ST_Crosses(poly, geom)` |\n| SpatiaLite | `Crosses(poly, geom)` |\n\n### `disjoint`\n\n*Availability*: [PostGIS](https://postgis.net/docs/ST_Disjoint.md),\nOracle, MariaDB, MySQL, SpatiaLite, PGRaster (Bilateral)\n\nTests if the geometry field is spatially disjoint from the lookup geometry.\n\nExample:\n\n```python\nZipcode.objects.filter(poly__disjoint=geom)\n```\n\n| Backend | SQL Equivalent |\n| --- | --- |\n| PostGIS | `ST_Disjoint(poly, geom)` |\n| Oracle | `SDO_GEOM.RELATE(poly, 'DISJOINT', geom, 0.05)` |\n| MariaDB | `ST_Disjoint(poly, geom)` |\n| MySQL | `ST_Disjoint(poly, geom)` |\n| SpatiaLite | `Disjoint(poly, geom)` |\n\n### `equals`\n\n*Availability*: [PostGIS](https://postgis.net/docs/ST_Equals.md),\nOracle, MariaDB, MySQL, SpatiaLite, PGRaster (Conversion)\n\nTests if the geometry field is spatially equal to the lookup geometry.\n\nExample:\n\n```python\nZipcode.objects.filter(poly__equals=geom)\n```\n\n| Backend | SQL Equivalent |\n| --- | --- |\n| PostGIS | `ST_Equals(poly, geom)` |\n| Oracle | `SDO_EQUAL(poly, geom)` |\n| Mari", "source_file_id": "django__5_2__ref__contrib__gis__geoquerysets.html", "headings": ["GIS QuerySet API Reference", "Spatial Lookups", "`disjoint`"], "order": 11, "level": 3, "tokens": 137, "code_languages": ["python"], "links_out": [{"text": "PostGIS", "href": "https://postgis.net/docs/ST_Disjoint.md"}], "id": "913cad65f3c07003", "char_count": 1355}
{"content": "f the geometry field is spatially disjoint from the lookup geometry.\n\nExample:\n\n```python\nZipcode.objects.filter(poly__disjoint=geom)\n```\n\n| Backend | SQL Equivalent |\n| --- | --- |\n| PostGIS | `ST_Disjoint(poly, geom)` |\n| Oracle | `SDO_GEOM.RELATE(poly, 'DISJOINT', geom, 0.05)` |\n| MariaDB | `ST_Disjoint(poly, geom)` |\n| MySQL | `ST_Disjoint(poly, geom)` |\n| SpatiaLite | `Disjoint(poly, geom)` |\n\n### `equals`\n\n*Availability*: [PostGIS](https://postgis.net/docs/ST_Equals.md),\nOracle, MariaDB, MySQL, SpatiaLite, PGRaster (Conversion)\n\nTests if the geometry field is spatially equal to the lookup geometry.\n\nExample:\n\n```python\nZipcode.objects.filter(poly__equals=geom)\n```\n\n| Backend | SQL Equivalent |\n| --- | --- |\n| PostGIS | `ST_Equals(poly, geom)` |\n| Oracle | `SDO_EQUAL(poly, geom)` |\n| MariaDB | `ST_Equals(poly, geom)` |\n| MySQL | `ST_Equals(poly, geom)` |\n| SpatiaLite | `Equals(poly, geom)` |\n\n### `exact`, `same_as`\n\n*Availability*: [PostGIS](https://postgis.net/docs/ST_Geometry_Same.md),\nOracle, MariaDB, MySQL, SpatiaLite, PGRaster (Bilateral)\n\nTests if the geometry field is \u201cequal\u201d to the lookup geometry. On Oracle,\nMySQL, and SpatiaLite, it tests spatial equality, while on PostGIS it tests\nequality of bounding boxes.\n\nExample:\n\n```python\nZipcode.objects.filter(poly=geom)\n```\n\n| Backe", "source_file_id": "django__5_2__ref__contrib__gis__geoquerysets.html", "headings": ["GIS QuerySet API Reference", "Spatial Lookups", "`equals`"], "order": 12, "level": 3, "tokens": 126, "code_languages": ["python"], "links_out": [{"text": "PostGIS", "href": "https://postgis.net/docs/ST_Equals.md"}], "id": "995a6fe3ea9c651a", "char_count": 1311}
{"content": "patiaLite, PGRaster (Conversion)\n\nTests if the geometry field is spatially equal to the lookup geometry.\n\nExample:\n\n```python\nZipcode.objects.filter(poly__equals=geom)\n```\n\n| Backend | SQL Equivalent |\n| --- | --- |\n| PostGIS | `ST_Equals(poly, geom)` |\n| Oracle | `SDO_EQUAL(poly, geom)` |\n| MariaDB | `ST_Equals(poly, geom)` |\n| MySQL | `ST_Equals(poly, geom)` |\n| SpatiaLite | `Equals(poly, geom)` |\n\n### `exact`, `same_as`\n\n*Availability*: [PostGIS](https://postgis.net/docs/ST_Geometry_Same.md),\nOracle, MariaDB, MySQL, SpatiaLite, PGRaster (Bilateral)\n\nTests if the geometry field is \u201cequal\u201d to the lookup geometry. On Oracle,\nMySQL, and SpatiaLite, it tests spatial equality, while on PostGIS it tests\nequality of bounding boxes.\n\nExample:\n\n```python\nZipcode.objects.filter(poly=geom)\n```\n\n| Backend | SQL Equivalent |\n| --- | --- |\n| PostGIS | `poly ~= geom` |\n| Oracle | `SDO_EQUAL(poly, geom)` |\n| MariaDB | `ST_Equals(poly, geom)` |\n| MySQL | `ST_Equals(poly, geom)` |\n| SpatiaLite | `Equals(poly, geom)` |\n\n### `intersects`\n\n*Availability*: [PostGIS](https://postgis.net/docs/ST_Intersects.md),\nOracle, MariaDB, MySQL, SpatiaLite, PGRaster (Bilateral)\n\nTests if the geometry field spatially intersects the lookup geometry.\n\nExample:\n\n```python\nZipcode.objects.filter(poly__intersects=geom)\n```\n\n| Backend | SQL Equivalent |\n| --- | --- |\n| PostGIS | `ST_Intersects(poly, geom)` |\n| Oracle | `SDO_OVERLAPBDYINT", "source_file_id": "django__5_2__ref__contrib__gis__geoquerysets.html", "headings": ["GIS QuerySet API Reference", "Spatial Lookups", "`exact`, `same_as`"], "order": 13, "level": 3, "tokens": 153, "code_languages": ["python"], "links_out": [{"text": "PostGIS", "href": "https://postgis.net/docs/ST_Geometry_Same.md"}], "id": "05bb79cc9913c3a2", "char_count": 1421}
{"content": "try. On Oracle,\nMySQL, and SpatiaLite, it tests spatial equality, while on PostGIS it tests\nequality of bounding boxes.\n\nExample:\n\n```python\nZipcode.objects.filter(poly=geom)\n```\n\n| Backend | SQL Equivalent |\n| --- | --- |\n| PostGIS | `poly ~= geom` |\n| Oracle | `SDO_EQUAL(poly, geom)` |\n| MariaDB | `ST_Equals(poly, geom)` |\n| MySQL | `ST_Equals(poly, geom)` |\n| SpatiaLite | `Equals(poly, geom)` |\n\n### `intersects`\n\n*Availability*: [PostGIS](https://postgis.net/docs/ST_Intersects.md),\nOracle, MariaDB, MySQL, SpatiaLite, PGRaster (Bilateral)\n\nTests if the geometry field spatially intersects the lookup geometry.\n\nExample:\n\n```python\nZipcode.objects.filter(poly__intersects=geom)\n```\n\n| Backend | SQL Equivalent |\n| --- | --- |\n| PostGIS | `ST_Intersects(poly, geom)` |\n| Oracle | `SDO_OVERLAPBDYINTERSECT(poly, geom)` |\n| MariaDB | `ST_Intersects(poly, geom)` |\n| MySQL | `ST_Intersects(poly, geom)` |\n| SpatiaLite | `Intersects(poly, geom)` |\n\n### `isempty`\n\n*Availability*: [PostGIS](https://postgis.net/docs/ST_IsEmpty.md)\n\nTests if the geometry is empty.\n\nExample:\n\n```python\nZipcode.objects.filter(poly__isempty=True)\n```", "source_file_id": "django__5_2__ref__contrib__gis__geoquerysets.html", "headings": ["GIS QuerySet API Reference", "Spatial Lookups", "`intersects`"], "order": 14, "level": 3, "tokens": 136, "code_languages": ["python"], "links_out": [{"text": "PostGIS", "href": "https://postgis.net/docs/ST_Intersects.md"}], "id": "78a2031014f5e17f", "char_count": 1132}
{"content": "\nTests if the geometry field spatially intersects the lookup geometry.\n\nExample:\n\n```python\nZipcode.objects.filter(poly__intersects=geom)\n```\n\n| Backend | SQL Equivalent |\n| --- | --- |\n| PostGIS | `ST_Intersects(poly, geom)` |\n| Oracle | `SDO_OVERLAPBDYINTERSECT(poly, geom)` |\n| MariaDB | `ST_Intersects(poly, geom)` |\n| MySQL | `ST_Intersects(poly, geom)` |\n| SpatiaLite | `Intersects(poly, geom)` |\n\n### `isempty`\n\n*Availability*: [PostGIS](https://postgis.net/docs/ST_IsEmpty.md)\n\nTests if the geometry is empty.\n\nExample:\n\n```python\nZipcode.objects.filter(poly__isempty=True)\n```\n\n### `isvalid`\n\n*Availability*: MySQL, [PostGIS](https://postgis.net/docs/ST_IsValid.md),\nOracle, SpatiaLite\n\nTests if the geometry is valid.\n\nExample:\n\n```python\nZipcode.objects.filter(poly__isvalid=True)\n```\n\n| Backend | SQL Equivalent |\n| --- | --- |\n| MySQL, PostGIS, SpatiaLite | `ST_IsValid(poly)` |\n| Oracle | `SDO_GEOM.VALIDATE_GEOMETRY_WITH_CONTEXT(poly, 0.05) = 'TRUE'` |", "source_file_id": "django__5_2__ref__contrib__gis__geoquerysets.html", "headings": ["GIS QuerySet API Reference", "Spatial Lookups", "`isempty`"], "order": 15, "level": 3, "tokens": 45, "code_languages": ["python"], "links_out": [{"text": "PostGIS", "href": "https://postgis.net/docs/ST_IsEmpty.md"}], "id": "9a04a307b396fa46", "char_count": 967}
{"content": "### `isempty`\n\n*Availability*: [PostGIS](https://postgis.net/docs/ST_IsEmpty.md)\n\nTests if the geometry is empty.\n\nExample:\n\n```python\nZipcode.objects.filter(poly__isempty=True)\n```\n\n### `isvalid`\n\n*Availability*: MySQL, [PostGIS](https://postgis.net/docs/ST_IsValid.md),\nOracle, SpatiaLite\n\nTests if the geometry is valid.\n\nExample:\n\n```python\nZipcode.objects.filter(poly__isvalid=True)\n```\n\n| Backend | SQL Equivalent |\n| --- | --- |\n| MySQL, PostGIS, SpatiaLite | `ST_IsValid(poly)` |\n| Oracle | `SDO_GEOM.VALIDATE_GEOMETRY_WITH_CONTEXT(poly, 0.05) = 'TRUE'` |\n\n### `overlaps`\n\n*Availability*: [PostGIS](https://postgis.net/docs/ST_Overlaps.md),\nOracle, MariaDB, MySQL, SpatiaLite, PGRaster (Bilateral)\n\nTests if the geometry field spatially overlaps the lookup geometry.\n\n| Backend | SQL Equivalent |\n| --- | --- |\n| PostGIS | `ST_Overlaps(poly, geom)` |\n| Oracle | `SDO_OVERLAPS(poly, geom)` |\n| MariaDB | `ST_Overlaps(poly, geom)` |\n| MySQL | `ST_Overlaps(poly,", "source_file_id": "django__5_2__ref__contrib__gis__geoquerysets.html", "headings": ["GIS QuerySet API Reference", "Spatial Lookups", "`isvalid`"], "order": 16, "level": 3, "tokens": 95, "code_languages": ["python"], "links_out": [{"text": "PostGIS", "href": "https://postgis.net/docs/ST_IsValid.md"}], "id": "42b58b295e429c1e", "char_count": 967}
{"content": "### `isvalid`\n\n*Availability*: MySQL, [PostGIS](https://postgis.net/docs/ST_IsValid.md),\nOracle, SpatiaLite\n\nTests if the geometry is valid.\n\nExample:\n\n```python\nZipcode.objects.filter(poly__isvalid=True)\n```\n\n| Backend | SQL Equivalent |\n| --- | --- |\n| MySQL, PostGIS, SpatiaLite | `ST_IsValid(poly)` |\n| Oracle | `SDO_GEOM.VALIDATE_GEOMETRY_WITH_CONTEXT(poly, 0.05) = 'TRUE'` |\n\n### `overlaps`\n\n*Availability*: [PostGIS](https://postgis.net/docs/ST_Overlaps.md),\nOracle, MariaDB, MySQL, SpatiaLite, PGRaster (Bilateral)\n\nTests if the geometry field spatially overlaps the lookup geometry.\n\n| Backend | SQL Equivalent |\n| --- | --- |\n| PostGIS | `ST_Overlaps(poly, geom)` |\n| Oracle | `SDO_OVERLAPS(poly, geom)` |\n| MariaDB | `ST_Overlaps(poly, geom)` |\n| MySQL | `ST_Overlaps(poly, geom)` |\n| SpatiaLite | `Overlaps(poly, geom)` |\n\n### `relate`\n\n*Availability*: [PostGIS](https://postgis.net/docs/ST_Relate.md),\nMariaDB, Oracle, SpatiaLite, PGRaster (Conversion)\n\nTests if the geometry field is spatially related to the lookup geometry by\nthe values given in the given pattern. This lookup requires a tuple parameter,\n`(geom, pattern)`; the form of `pattern` will depend on the spatial backend:\n\n#### MariaDB, PostGIS, and SpatiaLit", "source_file_id": "django__5_2__ref__contrib__gis__geoquerysets.html", "headings": ["GIS QuerySet API Reference", "Spatial Lookups", "`overlaps`"], "order": 17, "level": 3, "tokens": 112, "code_languages": [], "links_out": [{"text": "PostGIS", "href": "https://postgis.net/docs/ST_Overlaps.md"}], "id": "48d538c4149711a4", "char_count": 1235}
{"content": "/postgis.net/docs/ST_Overlaps.md),\nOracle, MariaDB, MySQL, SpatiaLite, PGRaster (Bilateral)\n\nTests if the geometry field spatially overlaps the lookup geometry.\n\n| Backend | SQL Equivalent |\n| --- | --- |\n| PostGIS | `ST_Overlaps(poly, geom)` |\n| Oracle | `SDO_OVERLAPS(poly, geom)` |\n| MariaDB | `ST_Overlaps(poly, geom)` |\n| MySQL | `ST_Overlaps(poly, geom)` |\n| SpatiaLite | `Overlaps(poly, geom)` |\n\n### `relate`\n\n*Availability*: [PostGIS](https://postgis.net/docs/ST_Relate.md),\nMariaDB, Oracle, SpatiaLite, PGRaster (Conversion)\n\nTests if the geometry field is spatially related to the lookup geometry by\nthe values given in the given pattern. This lookup requires a tuple parameter,\n`(geom, pattern)`; the form of `pattern` will depend on the spatial backend:\n\n#### MariaDB, PostGIS, and SpatiaLite\n\nOn these spatial backends the intersection pattern is a string comprising\nnine characters, which define intersections between the interior, boundary,\nand exterior of the geometry field and the lookup geometry.\nThe intersection pattern matrix may only use the following characters:\n`1`, `2`, `T`, `F`, or `*`. This lookup type allows users to \u201cfine tune\u201d\na specific geometric relationship consistent with the DE-9IM model. [[1]](#fnde9im)\n\nGeometry example:\n\n```python\n\n# A tuple lookup parameter is used to specify the geometry and", "source_file_id": "django__5_2__ref__contrib__gis__geoquerysets.html", "headings": ["GIS QuerySet API Reference", "Spatial Lookups", "`relate`"], "order": 18, "level": 3, "tokens": 217, "code_languages": [], "links_out": [{"text": "PostGIS", "href": "https://postgis.net/docs/ST_Relate.md"}], "id": "9a02bbaad0e3510e", "char_count": 1338}
{"content": "rising\nnine characters, which define intersections between the interior, boundary,\nand exterior of the geometry field and the lookup geometry.\nThe intersection pattern matrix may only use the following characters:\n`1`, `2`, `T`, `F`, or `*`. This lookup type allows users to \u201cfine tune\u201d\na specific geometric relationship consistent with the DE-9IM model. [[1]](#fnde9im)\n\nGeometry example:\n\n```python\n\n# A tuple lookup parameter is used to specify the geometry and\n\n# the intersection pattern (the pattern here is for 'contains').\nZipcode.objects.filter(poly__relate=(geom, \"T*T***FF*\"))\n```\n\nPostGIS and MariaDB SQL equivalent:\n\n```sql\nSELECT ... WHERE ST_Relate(poly, geom, 'T*T***FF*')\n```\n\nSpatiaLite SQL equivalent:\n\n```sql\nSELECT ... WHERE Relate(poly, geom, 'T*T***FF*')\n```\n\nRaster example:\n\n```python\nZipcode.objects.filter(poly__relate=(rast, 1, \"T*T***FF*", "source_file_id": "django__5_2__ref__contrib__gis__geoquerysets.html", "headings": ["A tuple lookup parameter is used to specify the geometry and"], "order": 19, "level": 1, "tokens": 15, "code_languages": [], "links_out": [], "id": "50f8a7293bde608d", "char_count": 866}
{"content": "# A tuple lookup parameter is used to specify the geometry and\n\n# the intersection pattern (the pattern here is for 'contains').\nZipcode.objects.filter(poly__relate=(geom, \"T*T***FF*\"))\n```\n\nPostGIS and MariaDB SQL equivalent:\n\n```sql\nSELECT ... WHERE ST_Relate(poly, geom, 'T*T***FF*')\n```\n\nSpatiaLite SQL equivalent:\n\n```sql\nSELECT ... WHERE Relate(poly, geom, 'T*T***FF*')\n```\n\nRaster example:\n\n```python\nZipcode.objects.filter(poly__relate=(rast, 1, \"T*T***FF*\"))\nZipcode.objects.filter(rast__2__relate=(rast, 1, \"T*T***FF*\"))\n```\n\nPostGIS SQL equivalent:\n\n```sql\nSELECT ... WHERE ST_Relate(poly, ST_Polygon(rast, 1), 'T*T***FF*')\nSELECT ... WHERE ST_Relate(ST_Polygon(rast, 2), ST_Polygon(rast, 1), 'T*T***FF*')\n```\n\n#### Oracle\n\nHere the relation pattern is comprised of at least one of the nine relation\nstrings: `TOUCH`, `OVERLAPBDYDISJOINT`, `OVERLAPBDYINTERSECT`,\n`EQUAL`, `INSIDE`, `COVEREDBY`, `CONTAINS`, `COVERS`, `ON`, and\n`ANYINTERACT`. Multiple strings may be combined with the logical Boolean\noperator OR, for example, `'inside+touch'`. [[2]](#fnsdorelate) The relation\nstrings are case-insensitive.\n\nExam", "source_file_id": "django__5_2__ref__contrib__gis__geoquerysets.html", "headings": ["the intersection pattern (the pattern here is for 'contains')."], "order": 20, "level": 1, "tokens": 164, "code_languages": ["python", "sql", "text"], "links_out": [], "id": "9bbbadce1e6e0b30", "char_count": 1123}
{"content": "```sql\nSELECT ... WHERE Relate(poly, geom, 'T*T***FF*')\n```\n\nRaster example:\n\n```python\nZipcode.objects.filter(poly__relate=(rast, 1, \"T*T***FF*\"))\nZipcode.objects.filter(rast__2__relate=(rast, 1, \"T*T***FF*\"))\n```\n\nPostGIS SQL equivalent:\n\n```sql\nSELECT ... WHERE ST_Relate(poly, ST_Polygon(rast, 1), 'T*T***FF*')\nSELECT ... WHERE ST_Relate(ST_Polygon(rast, 2), ST_Polygon(rast, 1), 'T*T***FF*')\n```\n\n#### Oracle\n\nHere the relation pattern is comprised of at least one of the nine relation\nstrings: `TOUCH`, `OVERLAPBDYDISJOINT`, `OVERLAPBDYINTERSECT`,\n`EQUAL`, `INSIDE`, `COVEREDBY`, `CONTAINS`, `COVERS`, `ON`, and\n`ANYINTERACT`. Multiple strings may be combined with the logical Boolean\noperator OR, for example, `'inside+touch'`. [[2]](#fnsdorelate) The relation\nstrings are case-insensitive.\n\nExample:\n\n```python\nZipcode.objects.filter(poly__relate=(geom, \"anyinteract\"))\n```\n\nOracle SQL equivalent:\n\n```sql\nSELECT ... WHERE SDO_RELATE(poly, geom, 'anyinteract')\n```\n\n### `touches`\n\n*Availability*: [PostGIS](https://postgis.net/docs/ST_Touches.md),\nOracle, MariaDB, MySQL, SpatiaLite\n\nTests if the geometry field spatially touches the lookup geometry.\n\nExample:\n\n```python\nZipcode.objects.filter(poly__touches=geom)\n```\n\n| Backend | SQL Equivalent |\n| --- | --- |\n| PostGIS | `ST_Touches(poly, geom)` |\n| MariaDB | `ST_Touches(poly, geom)` |\n| MySQL | `ST_Touches(poly,", "source_file_id": "django__5_2__ref__contrib__gis__geoquerysets.html", "headings": ["the intersection pattern (the pattern here is for 'contains').", "Oracle"], "order": 21, "level": 4, "tokens": 142, "code_languages": ["python", "sql"], "links_out": [], "id": "c96bae74e616c5f4", "char_count": 1376}
{"content": ", `COVEREDBY`, `CONTAINS`, `COVERS`, `ON`, and\n`ANYINTERACT`. Multiple strings may be combined with the logical Boolean\noperator OR, for example, `'inside+touch'`. [[2]](#fnsdorelate) The relation\nstrings are case-insensitive.\n\nExample:\n\n```python\nZipcode.objects.filter(poly__relate=(geom, \"anyinteract\"))\n```\n\nOracle SQL equivalent:\n\n```sql\nSELECT ... WHERE SDO_RELATE(poly, geom, 'anyinteract')\n```\n\n### `touches`\n\n*Availability*: [PostGIS](https://postgis.net/docs/ST_Touches.md),\nOracle, MariaDB, MySQL, SpatiaLite\n\nTests if the geometry field spatially touches the lookup geometry.\n\nExample:\n\n```python\nZipcode.objects.filter(poly__touches=geom)\n```\n\n| Backend | SQL Equivalent |\n| --- | --- |\n| PostGIS | `ST_Touches(poly, geom)` |\n| MariaDB | `ST_Touches(poly, geom)` |\n| MySQL | `ST_Touches(poly, geom)` |\n| Oracle | `SDO_TOUCH(poly, geom)` |\n| SpatiaLite | `Touches(poly, geom)` |\n\n### `within`\n\n*Availability*: [PostGIS](https://postgis.net/docs/ST_Within.md),\nOracle, MariaDB, MySQL, SpatiaLite, PGRaster (Bilateral)\n\nTests if the geometry field is spatially within the lookup geometry.\n\nExample:\n\n```python\nZipcode.objects.filter(poly__within=geom)\n```\n\n| Backend | SQL Equivalent |\n| --- | --- |\n| PostGIS | `ST_Within(poly, geom)` |\n| MariaDB | `ST_Within(poly, geom)` |\n| MySQ", "source_file_id": "django__5_2__ref__contrib__gis__geoquerysets.html", "headings": ["the intersection pattern (the pattern here is for 'contains').", "`touches`"], "order": 22, "level": 3, "tokens": 121, "code_languages": ["python"], "links_out": [{"text": "PostGIS", "href": "https://postgis.net/docs/ST_Touches.md"}], "id": "c3efe13d4e6226bd", "char_count": 1292}
{"content": "cle, MariaDB, MySQL, SpatiaLite\n\nTests if the geometry field spatially touches the lookup geometry.\n\nExample:\n\n```python\nZipcode.objects.filter(poly__touches=geom)\n```\n\n| Backend | SQL Equivalent |\n| --- | --- |\n| PostGIS | `ST_Touches(poly, geom)` |\n| MariaDB | `ST_Touches(poly, geom)` |\n| MySQL | `ST_Touches(poly, geom)` |\n| Oracle | `SDO_TOUCH(poly, geom)` |\n| SpatiaLite | `Touches(poly, geom)` |\n\n### `within`\n\n*Availability*: [PostGIS](https://postgis.net/docs/ST_Within.md),\nOracle, MariaDB, MySQL, SpatiaLite, PGRaster (Bilateral)\n\nTests if the geometry field is spatially within the lookup geometry.\n\nExample:\n\n```python\nZipcode.objects.filter(poly__within=geom)\n```\n\n| Backend | SQL Equivalent |\n| --- | --- |\n| PostGIS | `ST_Within(poly, geom)` |\n| MariaDB | `ST_Within(poly, geom)` |\n| MySQL | `ST_Within(poly, geom)` |\n| Oracle | `SDO_INSIDE(poly, geom)` |\n| SpatiaLite | `Within(poly, geom)` |\n\n### `left`\n\n*Availability*: [PostGIS](https://postgis.net/docs/ST_Geometry_Left.md),\nPGRaster (Conversion)\n\nTests if the geometry field\u2019s bounding box is strictly to the left of the\nlookup geometry\u2019s bounding box.\n\nExample:\n\n```python\nZipcode.objects.filter(poly__left=geom)\n```\n\nPostGIS equivalent:\n\n```sql\nSELECT ... WHERE poly << geom\n```", "source_file_id": "django__5_2__ref__contrib__gis__geoquerysets.html", "headings": ["the intersection pattern (the pattern here is for 'contains').", "`within`"], "order": 23, "level": 3, "tokens": 126, "code_languages": ["python"], "links_out": [{"text": "PostGIS", "href": "https://postgis.net/docs/ST_Within.md"}], "id": "dc1dc258686d766e", "char_count": 1252}
{"content": "patiaLite, PGRaster (Bilateral)\n\nTests if the geometry field is spatially within the lookup geometry.\n\nExample:\n\n```python\nZipcode.objects.filter(poly__within=geom)\n```\n\n| Backend | SQL Equivalent |\n| --- | --- |\n| PostGIS | `ST_Within(poly, geom)` |\n| MariaDB | `ST_Within(poly, geom)` |\n| MySQL | `ST_Within(poly, geom)` |\n| Oracle | `SDO_INSIDE(poly, geom)` |\n| SpatiaLite | `Within(poly, geom)` |\n\n### `left`\n\n*Availability*: [PostGIS](https://postgis.net/docs/ST_Geometry_Left.md),\nPGRaster (Conversion)\n\nTests if the geometry field\u2019s bounding box is strictly to the left of the\nlookup geometry\u2019s bounding box.\n\nExample:\n\n```python\nZipcode.objects.filter(poly__left=geom)\n```\n\nPostGIS equivalent:\n\n```sql\nSELECT ... WHERE poly << geom\n```\n\n### `right`\n\n*Availability*: [PostGIS](https://postgis.net/docs/ST_Geometry_Right.md),\nPGRaster (Conversion)\n\nTests if the geometry field\u2019s bounding box is strictly to the right of the\nlookup geometry\u2019s bounding box.\n\nExample:\n\n```python\nZipcode.objects.filter(poly__right=geom)\n```\n\nPostGIS equivalent:\n\n```sql\nSELECT ... WHERE poly >> geom\n```", "source_file_id": "django__5_2__ref__contrib__gis__geoquerysets.html", "headings": ["the intersection pattern (the pattern here is for 'contains').", "`left`"], "order": 24, "level": 3, "tokens": 85, "code_languages": ["python", "sql"], "links_out": [{"text": "PostGIS", "href": "https://postgis.net/docs/ST_Geometry_Left.md"}], "id": "d783a45159055bcb", "char_count": 1090}
{"content": "### `left`\n\n*Availability*: [PostGIS](https://postgis.net/docs/ST_Geometry_Left.md),\nPGRaster (Conversion)\n\nTests if the geometry field\u2019s bounding box is strictly to the left of the\nlookup geometry\u2019s bounding box.\n\nExample:\n\n```python\nZipcode.objects.filter(poly__left=geom)\n```\n\nPostGIS equivalent:\n\n```sql\nSELECT ... WHERE poly << geom\n```\n\n### `right`\n\n*Availability*: [PostGIS](https://postgis.net/docs/ST_Geometry_Right.md),\nPGRaster (Conversion)\n\nTests if the geometry field\u2019s bounding box is strictly to the right of the\nlookup geometry\u2019s bounding box.\n\nExample:\n\n```python\nZipcode.objects.filter(poly__right=geom)\n```\n\nPostGIS equivalent:\n\n```sql\nSELECT ... WHERE poly >> geom\n```\n\n### `overlaps_left`\n\n*Availability*: [PostGIS](https://postgis.net/docs/ST_Geometry_Overleft.md),\nPGRaster (Bilateral)\n\nTests if the geometry field\u2019s bounding box overlaps or is to the left of the lookup\ngeometry\u2019s bounding box.\n\nExample:\n\n```python\nZipcode.objects.filter(poly__overlaps_left=geom)\n```\n\nPostGIS equivalent:\n\n```sql\nSELECT ... WHERE poly &< geom\n```", "source_file_id": "django__5_2__ref__contrib__gis__geoquerysets.html", "headings": ["the intersection pattern (the pattern here is for 'contains').", "`right`"], "order": 25, "level": 3, "tokens": 86, "code_languages": ["python", "sql"], "links_out": [{"text": "PostGIS", "href": "https://postgis.net/docs/ST_Geometry_Right.md"}], "id": "97c1082f76730851", "char_count": 1055}
{"content": "### `right`\n\n*Availability*: [PostGIS](https://postgis.net/docs/ST_Geometry_Right.md),\nPGRaster (Conversion)\n\nTests if the geometry field\u2019s bounding box is strictly to the right of the\nlookup geometry\u2019s bounding box.\n\nExample:\n\n```python\nZipcode.objects.filter(poly__right=geom)\n```\n\nPostGIS equivalent:\n\n```sql\nSELECT ... WHERE poly >> geom\n```\n\n### `overlaps_left`\n\n*Availability*: [PostGIS](https://postgis.net/docs/ST_Geometry_Overleft.md),\nPGRaster (Bilateral)\n\nTests if the geometry field\u2019s bounding box overlaps or is to the left of the lookup\ngeometry\u2019s bounding box.\n\nExample:\n\n```python\nZipcode.objects.filter(poly__overlaps_left=geom)\n```\n\nPostGIS equivalent:\n\n```sql\nSELECT ... WHERE poly &< geom\n```\n\n### `overlaps_right`\n\n*Availability*: [PostGIS](https://postgis.net/docs/ST_Geometry_Overright.md),\nPGRaster (Bilateral)\n\nTests if the geometry field\u2019s bounding box overlaps or is to the right of the lookup\ngeometry\u2019s bounding box.\n\nExample:\n\n```python\nZipcode.objects.filter(poly__overlaps_right=geom)\n```\n\nPostGIS equivalent:\n\n```sql\nSELECT ... WHERE poly &> geom\n```", "source_file_id": "django__5_2__ref__contrib__gis__geoquerysets.html", "headings": ["the intersection pattern (the pattern here is for 'contains').", "`overlaps_left`"], "order": 26, "level": 3, "tokens": 91, "code_languages": ["python", "sql"], "links_out": [{"text": "PostGIS", "href": "https://postgis.net/docs/ST_Geometry_Overleft.md"}], "id": "eedfda1999afc573", "char_count": 1083}
{"content": "### `overlaps_left`\n\n*Availability*: [PostGIS](https://postgis.net/docs/ST_Geometry_Overleft.md),\nPGRaster (Bilateral)\n\nTests if the geometry field\u2019s bounding box overlaps or is to the left of the lookup\ngeometry\u2019s bounding box.\n\nExample:\n\n```python\nZipcode.objects.filter(poly__overlaps_left=geom)\n```\n\nPostGIS equivalent:\n\n```sql\nSELECT ... WHERE poly &< geom\n```\n\n### `overlaps_right`\n\n*Availability*: [PostGIS](https://postgis.net/docs/ST_Geometry_Overright.md),\nPGRaster (Bilateral)\n\nTests if the geometry field\u2019s bounding box overlaps or is to the right of the lookup\ngeometry\u2019s bounding box.\n\nExample:\n\n```python\nZipcode.objects.filter(poly__overlaps_right=geom)\n```\n\nPostGIS equivalent:\n\n```sql\nSELECT ... WHERE poly &> geom\n```\n\n### `overlaps_above`\n\n*Availability*: [PostGIS](https://postgis.net/docs/ST_Geometry_Overabove.md),\nPGRaster (Conversion)\n\nTests if the geometry field\u2019s bounding box overlaps or is above the lookup\ngeometry\u2019s bounding box.\n\nExample:\n\n```python\nZipcode.objects.filter(poly__overlaps_above=geom)\n```\n\nPostGIS equivalent:\n\n```sql\nSELECT ... WHERE poly |&> geom\n```", "source_file_id": "django__5_2__ref__contrib__gis__geoquerysets.html", "headings": ["the intersection pattern (the pattern here is for 'contains').", "`overlaps_right`"], "order": 27, "level": 3, "tokens": 92, "code_languages": ["python", "sql"], "links_out": [{"text": "PostGIS", "href": "https://postgis.net/docs/ST_Geometry_Overright.md"}], "id": "713df1ecdefe4baa", "char_count": 1099}
{"content": "### `overlaps_right`\n\n*Availability*: [PostGIS](https://postgis.net/docs/ST_Geometry_Overright.md),\nPGRaster (Bilateral)\n\nTests if the geometry field\u2019s bounding box overlaps or is to the right of the lookup\ngeometry\u2019s bounding box.\n\nExample:\n\n```python\nZipcode.objects.filter(poly__overlaps_right=geom)\n```\n\nPostGIS equivalent:\n\n```sql\nSELECT ... WHERE poly &> geom\n```\n\n### `overlaps_above`\n\n*Availability*: [PostGIS](https://postgis.net/docs/ST_Geometry_Overabove.md),\nPGRaster (Conversion)\n\nTests if the geometry field\u2019s bounding box overlaps or is above the lookup\ngeometry\u2019s bounding box.\n\nExample:\n\n```python\nZipcode.objects.filter(poly__overlaps_above=geom)\n```\n\nPostGIS equivalent:\n\n```sql\nSELECT ... WHERE poly |&> geom\n```\n\n### `overlaps_below`\n\n*Availability*: [PostGIS](https://postgis.net/docs/ST_Geometry_Overbelow.md),\nPGRaster (Conversion)\n\nTests if the geometry field\u2019s bounding box overlaps or is below the lookup\ngeometry\u2019s bounding box.\n\nExample:\n\n```python\nZipcode.objects.filter(poly__overlaps_below=geom)\n```\n\nPostGIS equivalent:\n\n```sql\nSELECT ... WHERE poly &<| geom\n```", "source_file_id": "django__5_2__ref__contrib__gis__geoquerysets.html", "headings": ["the intersection pattern (the pattern here is for 'contains').", "`overlaps_above`"], "order": 28, "level": 3, "tokens": 90, "code_languages": ["python", "sql"], "links_out": [{"text": "PostGIS", "href": "https://postgis.net/docs/ST_Geometry_Overabove.md"}], "id": "823d65ea7656f659", "char_count": 1095}
{"content": "### `overlaps_above`\n\n*Availability*: [PostGIS](https://postgis.net/docs/ST_Geometry_Overabove.md),\nPGRaster (Conversion)\n\nTests if the geometry field\u2019s bounding box overlaps or is above the lookup\ngeometry\u2019s bounding box.\n\nExample:\n\n```python\nZipcode.objects.filter(poly__overlaps_above=geom)\n```\n\nPostGIS equivalent:\n\n```sql\nSELECT ... WHERE poly |&> geom\n```\n\n### `overlaps_below`\n\n*Availability*: [PostGIS](https://postgis.net/docs/ST_Geometry_Overbelow.md),\nPGRaster (Conversion)\n\nTests if the geometry field\u2019s bounding box overlaps or is below the lookup\ngeometry\u2019s bounding box.\n\nExample:\n\n```python\nZipcode.objects.filter(poly__overlaps_below=geom)\n```\n\nPostGIS equivalent:\n\n```sql\nSELECT ... WHERE poly &<| geom\n```\n\n### `strictly_above`\n\n*Availability*: [PostGIS](https://postgis.net/docs/ST_Geometry_Above.md),\nPGRaster (Conversion)\n\nTests if the geometry field\u2019s bounding box is strictly above the lookup\ngeometry\u2019s bounding box.\n\nExample:\n\n```python\nZipcode.objects.filter(poly__strictly_above=geom)\n```\n\nPostGIS equivalent:\n\n```sql\nSELECT ... WHERE poly |>> geom\n```", "source_file_id": "django__5_2__ref__contrib__gis__geoquerysets.html", "headings": ["the intersection pattern (the pattern here is for 'contains').", "`overlaps_below`"], "order": 29, "level": 3, "tokens": 90, "code_languages": ["python", "sql"], "links_out": [{"text": "PostGIS", "href": "https://postgis.net/docs/ST_Geometry_Overbelow.md"}], "id": "8baba08326699ea3", "char_count": 1080}
{"content": "### `overlaps_below`\n\n*Availability*: [PostGIS](https://postgis.net/docs/ST_Geometry_Overbelow.md),\nPGRaster (Conversion)\n\nTests if the geometry field\u2019s bounding box overlaps or is below the lookup\ngeometry\u2019s bounding box.\n\nExample:\n\n```python\nZipcode.objects.filter(poly__overlaps_below=geom)\n```\n\nPostGIS equivalent:\n\n```sql\nSELECT ... WHERE poly &<| geom\n```\n\n### `strictly_above`\n\n*Availability*: [PostGIS](https://postgis.net/docs/ST_Geometry_Above.md),\nPGRaster (Conversion)\n\nTests if the geometry field\u2019s bounding box is strictly above the lookup\ngeometry\u2019s bounding box.\n\nExample:\n\n```python\nZipcode.objects.filter(poly__strictly_above=geom)\n```\n\nPostGIS equivalent:\n\n```sql\nSELECT ... WHERE poly |>> geom\n```\n\n### `strictly_below`\n\n*Availability*: [PostGIS](https://postgis.net/docs/ST_Geometry_Below.md),\nPGRaster (Conversion)\n\nTests if the geometry field\u2019s bounding box is strictly below the lookup\ngeometry\u2019s bounding box.\n\nExample:\n\n```python\nZipcode.objects.filter(poly__strictly_below=geom)\n```\n\nPostGIS equivalent:\n\n```sql\nSELECT ... WHERE poly <<| geom\n```", "source_file_id": "django__5_2__ref__contrib__gis__geoquerysets.html", "headings": ["the intersection pattern (the pattern here is for 'contains').", "`strictly_above`"], "order": 30, "level": 3, "tokens": 88, "code_languages": ["python", "sql"], "links_out": [{"text": "PostGIS", "href": "https://postgis.net/docs/ST_Geometry_Above.md"}], "id": "61296e06366a1cf1", "char_count": 1073}
{"content": "### `strictly_above`\n\n*Availability*: [PostGIS](https://postgis.net/docs/ST_Geometry_Above.md),\nPGRaster (Conversion)\n\nTests if the geometry field\u2019s bounding box is strictly above the lookup\ngeometry\u2019s bounding box.\n\nExample:\n\n```python\nZipcode.objects.filter(poly__strictly_above=geom)\n```\n\nPostGIS equivalent:\n\n```sql\nSELECT ... WHERE poly |>> geom\n```\n\n### `strictly_below`\n\n*Availability*: [PostGIS](https://postgis.net/docs/ST_Geometry_Below.md),\nPGRaster (Conversion)\n\nTests if the geometry field\u2019s bounding box is strictly below the lookup\ngeometry\u2019s bounding box.\n\nExample:\n\n```python\nZipcode.objects.filter(poly__strictly_below=geom)\n```\n\nPostGIS equivalent:\n\n```sql\nSELECT ... WHERE poly <<| geom\n```\n\n## Distance Lookups\n\n*Availability*: PostGIS, Oracle, MariaDB, MySQL, SpatiaLite, PGRaster (Native)\n\nFor an overview on performing distance queries, please refer to\nthe [distance queries introduction](db-api.md#distance-queries).\n\nDistance lookups take the following form:\n\n```text\n<field>__<distance lookup>=(<geometry/raster>, <distance value>[, \"spheroid\"])\n<field>__<distance lookup>=(<raster>, <", "source_file_id": "django__5_2__ref__contrib__gis__geoquerysets.html", "headings": ["the intersection pattern (the pattern here is for 'contains').", "`strictly_below`"], "order": 31, "level": 3, "tokens": 88, "code_languages": ["python", "sql"], "links_out": [{"text": "PostGIS", "href": "https://postgis.net/docs/ST_Geometry_Below.md"}], "id": "8ec5aab5820df0ee", "char_count": 1112}
{"content": "### `strictly_below`\n\n*Availability*: [PostGIS](https://postgis.net/docs/ST_Geometry_Below.md),\nPGRaster (Conversion)\n\nTests if the geometry field\u2019s bounding box is strictly below the lookup\ngeometry\u2019s bounding box.\n\nExample:\n\n```python\nZipcode.objects.filter(poly__strictly_below=geom)\n```\n\nPostGIS equivalent:\n\n```sql\nSELECT ... WHERE poly <<| geom\n```\n\n## Distance Lookups\n\n*Availability*: PostGIS, Oracle, MariaDB, MySQL, SpatiaLite, PGRaster (Native)\n\nFor an overview on performing distance queries, please refer to\nthe [distance queries introduction](db-api.md#distance-queries).\n\nDistance lookups take the following form:\n\n```text\n<field>__<distance lookup>=(<geometry/raster>, <distance value>[, \"spheroid\"])\n<field>__<distance lookup>=(<raster>, <band_index>, <distance value>[, \"spheroid\"])\n<field>__<band_index>__<distance lookup>=(<raster>, <band_index>, <distance value>[, \"spheroid\"])\n```\n\nThe value passed into a distance lookup is a tuple; the first two\nvalues are mandatory, and are the geometry to calculate distances to,\nand a distance value (either a number in units of the field, a\n[`Distance`](measure.md#django.contrib.gis.measure.Distance) object, or a [query\nexpression](../../models/expressions.md)). To pass a band index to the lookup, use\na 3-tuple where the second entry is the band index.\n\nOn every distance lookup except [`dwithin`](#std-fieldlookup-dwithin), an optional element,\n`'spheroid'`, may be included to use the more accurate spheroid distance\ncalculation functions on fields with a geodetic coordinate system.\n\nOn PostgreSQL, the `'spheroid'` option uses [ST\\_DistanceSpheroid](https://postgis.net/docs/ST_Distance_Spheroid.md) instead of\n[ST\\_DistanceSphere](https://postgis.net/docs/ST_DistanceSphere.md). The\nsimpler [ST\\_Distance](https://postgis.net/docs/ST_Distance.md) function is\nused with projected coordinate systems. Rasters are converted to geometries for\nspheroid based lookups.\n\n### `distance_gt`\n\nReturns models where the distance to the geometry field from the lookup\ngeometry is greater than the given distance value.\n\nExample:\n\n```python\nZipcode.objects.filter(poly__distance_gt=(geom, D(m=5)))\n```\n\n| Backend | SQL Equivalent |\n| --- | --- |\n| PostGIS | `ST_Distance/ST_Distance_Sphere(poly, geom) > 5` |\n| MariaDB | `ST_Distance(poly, geom) > 5` |\n| MySQL | `ST_Distance(poly", "source_file_id": "django__5_2__ref__contrib__gis__geoquerysets.html", "headings": ["the intersection pattern (the pattern here is for 'contains').", "Distance Lookups"], "order": 32, "level": 2, "tokens": 394, "code_languages": ["python", "text"], "links_out": [{"text": "distance queries introduction", "href": "db-api.md#distance-queries"}, {"text": "`Distance`", "href": "measure.md#django.contrib.gis.measure.Distance"}, {"text": "query\nexpression", "href": "../../models/expressions.md"}, {"text": "`dwithin`", "href": "#std-fieldlookup-dwithin"}, {"text": "ST\\_DistanceSpheroid", "href": "https://postgis.net/docs/ST_Distance_Spheroid.md"}, {"text": "ST\\_DistanceSphere", "href": "https://postgis.net/docs/ST_DistanceSphere.md"}, {"text": "ST\\_Distance", "href": "https://postgis.net/docs/ST_Distance.md"}], "id": "fca8207ab2da491c", "char_count": 2337}
{"content": "coordinate system.\n\nOn PostgreSQL, the `'spheroid'` option uses [ST\\_DistanceSpheroid](https://postgis.net/docs/ST_Distance_Spheroid.md) instead of\n[ST\\_DistanceSphere](https://postgis.net/docs/ST_DistanceSphere.md). The\nsimpler [ST\\_Distance](https://postgis.net/docs/ST_Distance.md) function is\nused with projected coordinate systems. Rasters are converted to geometries for\nspheroid based lookups.\n\n### `distance_gt`\n\nReturns models where the distance to the geometry field from the lookup\ngeometry is greater than the given distance value.\n\nExample:\n\n```python\nZipcode.objects.filter(poly__distance_gt=(geom, D(m=5)))\n```\n\n| Backend | SQL Equivalent |\n| --- | --- |\n| PostGIS | `ST_Distance/ST_Distance_Sphere(poly, geom) > 5` |\n| MariaDB | `ST_Distance(poly, geom) > 5` |\n| MySQL | `ST_Distance(poly, geom) > 5` |\n| Oracle | `SDO_GEOM.SDO_DISTANCE(poly, geom, 0.05) > 5` |\n| SpatiaLite | `Distance(poly, geom) > 5` |\n\n### `distance_gte`\n\nReturns models where the distance to the geometry field from the lookup\ngeometry is greater than or equal to the given distance value.\n\nExample:\n\n```python\nZipcode.objects.filter(poly__distance_gte=(geom, D(m=5)))\n```\n\n| Backend | SQL Equivalent |\n| --- | --- |\n| PostGIS | `ST_Distance/ST_Distance_Sphere(poly, geom) >= 5` |\n| MariaDB | `ST_Distance(poly, geom) >= 5` |\n| MySQL | ", "source_file_id": "django__5_2__ref__contrib__gis__geoquerysets.html", "headings": ["the intersection pattern (the pattern here is for 'contains').", "Distance Lookups", "`distance_gt`"], "order": 33, "level": 3, "tokens": 129, "code_languages": ["python"], "links_out": [], "id": "2e1bb2f2629c49b7", "char_count": 1324}
{"content": "he given distance value.\n\nExample:\n\n```python\nZipcode.objects.filter(poly__distance_gt=(geom, D(m=5)))\n```\n\n| Backend | SQL Equivalent |\n| --- | --- |\n| PostGIS | `ST_Distance/ST_Distance_Sphere(poly, geom) > 5` |\n| MariaDB | `ST_Distance(poly, geom) > 5` |\n| MySQL | `ST_Distance(poly, geom) > 5` |\n| Oracle | `SDO_GEOM.SDO_DISTANCE(poly, geom, 0.05) > 5` |\n| SpatiaLite | `Distance(poly, geom) > 5` |\n\n### `distance_gte`\n\nReturns models where the distance to the geometry field from the lookup\ngeometry is greater than or equal to the given distance value.\n\nExample:\n\n```python\nZipcode.objects.filter(poly__distance_gte=(geom, D(m=5)))\n```\n\n| Backend | SQL Equivalent |\n| --- | --- |\n| PostGIS | `ST_Distance/ST_Distance_Sphere(poly, geom) >= 5` |\n| MariaDB | `ST_Distance(poly, geom) >= 5` |\n| MySQL | `ST_Distance(poly, geom) >= 5` |\n| Oracle | `SDO_GEOM.SDO_DISTANCE(poly, geom, 0.05) >= 5` |\n| SpatiaLite | `Distance(poly, geom) >= 5` |\n\n### `distance_lt`\n\nReturns models where the distance to the geometry field from the lookup\ngeometry is less than the given distance value.\n\nExample:\n\n```python\nZipcode.objects.filter(poly__distance_lt=(geom, D(m=5)))\n```\n\n| Backend | SQL Equivalent |\n| --- | --- |\n| PostGIS | `ST_Distance/ST_Distance_Sphere(poly, geom) < 5` |\n| MariaDB | `ST_Distance(poly, geom) < 5` |\n| MySQL | `ST_Distance(poly,", "source_file_id": "django__5_2__ref__contrib__gis__geoquerysets.html", "headings": ["the intersection pattern (the pattern here is for 'contains').", "Distance Lookups", "`distance_gte`"], "order": 34, "level": 3, "tokens": 134, "code_languages": ["python"], "links_out": [], "id": "1fd6529382f4ffa7", "char_count": 1344}
{"content": "n distance value.\n\nExample:\n\n```python\nZipcode.objects.filter(poly__distance_gte=(geom, D(m=5)))\n```\n\n| Backend | SQL Equivalent |\n| --- | --- |\n| PostGIS | `ST_Distance/ST_Distance_Sphere(poly, geom) >= 5` |\n| MariaDB | `ST_Distance(poly, geom) >= 5` |\n| MySQL | `ST_Distance(poly, geom) >= 5` |\n| Oracle | `SDO_GEOM.SDO_DISTANCE(poly, geom, 0.05) >= 5` |\n| SpatiaLite | `Distance(poly, geom) >= 5` |\n\n### `distance_lt`\n\nReturns models where the distance to the geometry field from the lookup\ngeometry is less than the given distance value.\n\nExample:\n\n```python\nZipcode.objects.filter(poly__distance_lt=(geom, D(m=5)))\n```\n\n| Backend | SQL Equivalent |\n| --- | --- |\n| PostGIS | `ST_Distance/ST_Distance_Sphere(poly, geom) < 5` |\n| MariaDB | `ST_Distance(poly, geom) < 5` |\n| MySQL | `ST_Distance(poly, geom) < 5` |\n| Oracle | `SDO_GEOM.SDO_DISTANCE(poly, geom, 0.05) < 5` |\n| SpatiaLite | `Distance(poly, geom) < 5` |\n\n### `distance_lte`\n\nReturns models where the distance to the geometry field from the lookup\ngeometry is less than or equal to the given distance value.\n\nExample:\n\n```python\nZipcode.objects.filter(poly__distance_lte=(geom, D(m=5)))\n```\n\n| Backend | SQL Equivalent |\n| --- | --- |\n| PostGIS | `ST_Distance/ST_Distance_Sphere(poly, geom) <= 5` |\n| MariaDB | `ST_Distance(poly, geom) <= 5` |\n| MySQL | `ST_", "source_file_id": "django__5_2__ref__contrib__gis__geoquerysets.html", "headings": ["the intersection pattern (the pattern here is for 'contains').", "Distance Lookups", "`distance_lt`"], "order": 35, "level": 3, "tokens": 129, "code_languages": ["python"], "links_out": [], "id": "84c6174a5b91ac4d", "char_count": 1323}
{"content": " given distance value.\n\nExample:\n\n```python\nZipcode.objects.filter(poly__distance_lt=(geom, D(m=5)))\n```\n\n| Backend | SQL Equivalent |\n| --- | --- |\n| PostGIS | `ST_Distance/ST_Distance_Sphere(poly, geom) < 5` |\n| MariaDB | `ST_Distance(poly, geom) < 5` |\n| MySQL | `ST_Distance(poly, geom) < 5` |\n| Oracle | `SDO_GEOM.SDO_DISTANCE(poly, geom, 0.05) < 5` |\n| SpatiaLite | `Distance(poly, geom) < 5` |\n\n### `distance_lte`\n\nReturns models where the distance to the geometry field from the lookup\ngeometry is less than or equal to the given distance value.\n\nExample:\n\n```python\nZipcode.objects.filter(poly__distance_lte=(geom, D(m=5)))\n```\n\n| Backend | SQL Equivalent |\n| --- | --- |\n| PostGIS | `ST_Distance/ST_Distance_Sphere(poly, geom) <= 5` |\n| MariaDB | `ST_Distance(poly, geom) <= 5` |\n| MySQL | `ST_Distance(poly, geom) <= 5` |\n| Oracle | `SDO_GEOM.SDO_DISTANCE(poly, geom, 0.05) <= 5` |\n| SpatiaLite | `Distance(poly, geom) <= 5` |\n\n### `dwithin`\n\nReturns models where the distance to the geometry field from the lookup\ngeometry are within the given distance from one another. Note that you can only\nprovide [`Distance`](measure.md#django.contrib.gis.measure.Distance) objects if the targeted\ngeometries are in a projected system. For geographic geometries, you should use\nunits of the geometry field (e.g. degrees for `WGS84`) .\n\nEx", "source_file_id": "django__5_2__ref__contrib__gis__geoquerysets.html", "headings": ["the intersection pattern (the pattern here is for 'contains').", "Distance Lookups", "`distance_lte`"], "order": 36, "level": 3, "tokens": 133, "code_languages": ["python"], "links_out": [], "id": "db698bbeb3ca5ec4", "char_count": 1339}
{"content": "en distance value.\n\nExample:\n\n```python\nZipcode.objects.filter(poly__distance_lte=(geom, D(m=5)))\n```\n\n| Backend | SQL Equivalent |\n| --- | --- |\n| PostGIS | `ST_Distance/ST_Distance_Sphere(poly, geom) <= 5` |\n| MariaDB | `ST_Distance(poly, geom) <= 5` |\n| MySQL | `ST_Distance(poly, geom) <= 5` |\n| Oracle | `SDO_GEOM.SDO_DISTANCE(poly, geom, 0.05) <= 5` |\n| SpatiaLite | `Distance(poly, geom) <= 5` |\n\n### `dwithin`\n\nReturns models where the distance to the geometry field from the lookup\ngeometry are within the given distance from one another. Note that you can only\nprovide [`Distance`](measure.md#django.contrib.gis.measure.Distance) objects if the targeted\ngeometries are in a projected system. For geographic geometries, you should use\nunits of the geometry field (e.g. degrees for `WGS84`) .\n\nExample:\n\n```python\nZipcode.objects.filter(poly__dwithin=(geom, D(m=5)))\n```\n\n| Backend | SQL Equivalent |\n| --- | --- |\n| PostGIS | `ST_DWithin(poly, geom, 5)` |\n| Oracle | `SDO_WITHIN_DISTANCE(poly, geom, 5)` |\n| SpatiaLite | `PtDistWithin(poly, geom, 5)` |\n\n### Aggregate Functions\n\nDjango provides some GIS-specific aggregate functions. For details on how to\nuse these aggregate functions, see [the topic guide on aggregation](../../../topics/db/aggregation.md).\n\n| Keyword Argument | Description |\n| --- | --- |\n| `tolerance` | This keyword is for Oracle only. It is for the tolerance value used by the `SDOAGGRTYPE` procedure; the [Oracle documentation](h", "source_file_id": "django__5_2__ref__contrib__gis__geoquerysets.html", "headings": ["the intersection pattern (the pattern here is for 'contains').", "Distance Lookups", "`dwithin`"], "order": 37, "level": 3, "tokens": 164, "code_languages": ["python"], "links_out": [{"text": "`Distance`", "href": "measure.md#django.contrib.gis.measure.Distance"}], "id": "c3ab28f36912e989", "char_count": 1463}
{"content": "ed\ngeometries are in a projected system. For geographic geometries, you should use\nunits of the geometry field (e.g. degrees for `WGS84`) .\n\nExample:\n\n```python\nZipcode.objects.filter(poly__dwithin=(geom, D(m=5)))\n```\n\n| Backend | SQL Equivalent |\n| --- | --- |\n| PostGIS | `ST_DWithin(poly, geom, 5)` |\n| Oracle | `SDO_WITHIN_DISTANCE(poly, geom, 5)` |\n| SpatiaLite | `PtDistWithin(poly, geom, 5)` |\n\n### Aggregate Functions\n\nDjango provides some GIS-specific aggregate functions. For details on how to\nuse these aggregate functions, see [the topic guide on aggregation](../../../topics/db/aggregation.md).\n\n| Keyword Argument | Description |\n| --- | --- |\n| `tolerance` | This keyword is for Oracle only. It is for the tolerance value used by the `SDOAGGRTYPE` procedure; the [Oracle documentation](https://docs.oracle.com/en/database/oracle/oracle-database/21/spatl/spatial-concepts.md#GUID-CE10AB14-D5EA-43BA-A647-DAC9EEF41EE6) has more details. |\n\nExample:\n\n```python\n>>> from django.contrib.gis.db.models import Extent, Union\n>>> WorldBorder.objects.aggregate(Extent(\"mpoly\"), Union(\"mpoly\"))\n```\n\n#### `Collect`\n\n`classCollect(geo_field,filter=None)`[[source]](https://github.com/django/django/blob/stable/5.2.x/django/contrib/gis/db/models/aggregates.py#L61)\n\n*Availability*: [PostGIS](https://postgis.net/docs/ST_Collect.md), MySQL,\nSpatiaLite\n\nReturns a `GEOMETRYCOLLECTION` or a `MULTI` geometry object from the geometry\ncolumn. This is analogous to a simplified version of the [`Union`](#djang", "source_file_id": "django__5_2__ref__contrib__gis__geoquerysets.html", "headings": ["the intersection pattern (the pattern here is for 'contains').", "Distance Lookups", "Aggregate Functions"], "order": 38, "level": 3, "tokens": 175, "code_languages": ["python"], "links_out": [{"text": "the topic guide on aggregation", "href": "../../../topics/db/aggregation.md"}, {"text": "Oracle documentation", "href": "https://docs.oracle.com/en/database/oracle/oracle-database/21/spatl/spatial-concepts.md#GUID-CE10AB14-D5EA-43BA-A647-DAC9EEF41EE6"}], "id": "603513b8c491be09", "char_count": 1505}
{"content": "nly. It is for the tolerance value used by the `SDOAGGRTYPE` procedure; the [Oracle documentation](https://docs.oracle.com/en/database/oracle/oracle-database/21/spatl/spatial-concepts.md#GUID-CE10AB14-D5EA-43BA-A647-DAC9EEF41EE6) has more details. |\n\nExample:\n\n```python\n>>> from django.contrib.gis.db.models import Extent, Union\n>>> WorldBorder.objects.aggregate(Extent(\"mpoly\"), Union(\"mpoly\"))\n```\n\n#### `Collect`\n\n`classCollect(geo_field,filter=None)`[[source]](https://github.com/django/django/blob/stable/5.2.x/django/contrib/gis/db/models/aggregates.py#L61)\n\n*Availability*: [PostGIS](https://postgis.net/docs/ST_Collect.md), MySQL,\nSpatiaLite\n\nReturns a `GEOMETRYCOLLECTION` or a `MULTI` geometry object from the geometry\ncolumn. This is analogous to a simplified version of the [`Union`](#django.contrib.gis.db.models.Union)\naggregate, except it can be several orders of magnitude faster than performing\na union because it rolls up geometries into a collection or multi object, not\ncaring about dissolving boundaries.\n\n> **Changed in Django 5.1:**\n>\n> MySQL 8.0.24+ support was added.\n\n#### `Extent`\n\n`classExtent(geo_field,filter=None)`[[source]](https://github.com/django/django/blob/stable/5.2.x/django/contrib/gis/db/models/aggregates.py#L66)\n\n*Availability*: [PostGIS](https://postgis.net/docs/ST_Extent.md),\nOracle, SpatiaLite\n\nReturns the extent of all `geo_field` in the `QuerySet` as a 4-tuple,\ncomprising the lower left coordinate and the upper right coordinate.\n\nExample:\n\n```", "source_file_id": "django__5_2__ref__contrib__gis__geoquerysets.html", "headings": ["the intersection pattern (the pattern here is for 'contains').", "Distance Lookups", "Aggregate Functions", "`Collect`"], "order": 39, "level": 4, "tokens": 172, "code_languages": [], "links_out": [{"text": "PostGIS", "href": "https://postgis.net/docs/ST_Collect.md"}, {"text": "`Union`", "href": "#django.contrib.gis.db.models.Union"}], "id": "eadff1bc27f4c52f", "char_count": 1496}
{"content": "TI` geometry object from the geometry\ncolumn. This is analogous to a simplified version of the [`Union`](#django.contrib.gis.db.models.Union)\naggregate, except it can be several orders of magnitude faster than performing\na union because it rolls up geometries into a collection or multi object, not\ncaring about dissolving boundaries.\n\n> **Changed in Django 5.1:**\n>\n> MySQL 8.0.24+ support was added.\n\n#### `Extent`\n\n`classExtent(geo_field,filter=None)`[[source]](https://github.com/django/django/blob/stable/5.2.x/django/contrib/gis/db/models/aggregates.py#L66)\n\n*Availability*: [PostGIS](https://postgis.net/docs/ST_Extent.md),\nOracle, SpatiaLite\n\nReturns the extent of all `geo_field` in the `QuerySet` as a 4-tuple,\ncomprising the lower left coordinate and the upper right coordinate.\n\nExample:\n\n```python\n>>> qs = City.objects.filter(name__in=(\"Houston\", \"Dallas\")).aggregate(Extent(\"poly\"))\n>>> print(qs[\"poly__extent\"])\n(-96.8016128540039, 29.7633724212646, -95.3631439208984, 32.782058715820)\n```\n\n#### `Extent3D`\n\n`classExtent3D(geo_field,filter=None)`[[source]](https://github.com/django/django/blob/stable/5.2.x/django/contrib/gis/db/models/aggregates.py#L77)\n\n*Availability*: [PostGIS](https://postgis.net/docs/ST_3DExtent.md)\n\nReturns the 3D extent of all `geo_field` in the `QuerySet` as a 6-tuple,\ncomprising the lower left coordinate and upper right coordinate (each with x, y,\nand z coordi", "source_file_id": "django__5_2__ref__contrib__gis__geoquerysets.html", "headings": ["the intersection pattern (the pattern here is for 'contains').", "Distance Lookups", "Aggregate Functions", "`Extent`"], "order": 40, "level": 4, "tokens": 150, "code_languages": ["python"], "links_out": [{"text": "PostGIS", "href": "https://postgis.net/docs/ST_Extent.md"}], "id": "8c1e904b41c11320", "char_count": 1407}
{"content": "is.net/docs/ST_Extent.md),\nOracle, SpatiaLite\n\nReturns the extent of all `geo_field` in the `QuerySet` as a 4-tuple,\ncomprising the lower left coordinate and the upper right coordinate.\n\nExample:\n\n```python\n>>> qs = City.objects.filter(name__in=(\"Houston\", \"Dallas\")).aggregate(Extent(\"poly\"))\n>>> print(qs[\"poly__extent\"])\n(-96.8016128540039, 29.7633724212646, -95.3631439208984, 32.782058715820)\n```\n\n#### `Extent3D`\n\n`classExtent3D(geo_field,filter=None)`[[source]](https://github.com/django/django/blob/stable/5.2.x/django/contrib/gis/db/models/aggregates.py#L77)\n\n*Availability*: [PostGIS](https://postgis.net/docs/ST_3DExtent.md)\n\nReturns the 3D extent of all `geo_field` in the `QuerySet` as a 6-tuple,\ncomprising the lower left coordinate and upper right coordinate (each with x, y,\nand z coordinates).\n\nExample:\n\n```python\n>>> qs = City.objects.filter(name__in=(\"Houston\", \"Dallas\")).aggregate(Extent3D(\"poly\"))\n>>> print(qs[\"poly__extent3d\"])\n(-96.8016128540039, 29.7633724212646, 0, -95.3631439208984, 32.782058715820, 0)\n```\n\n#### `MakeLine`\n\n`classMakeLine(geo_field,filter=None)`[[source]](https://github.com/django/django/blob/stable/5.2.x/django/contrib/gis/db/models/aggregates.py#L88)\n\n*Availability*: [PostGIS](https://postgis.net/docs/ST_MakeLine.md),\nSpatiaLite\n\nReturns a `LineString` constructed from the point field geometries in the\n`QuerySet`. Currently, ordering the queryset has no effect.\n\nExample:\n\n```python", "source_file_id": "django__5_2__ref__contrib__gis__geoquerysets.html", "headings": ["the intersection pattern (the pattern here is for 'contains').", "Distance Lookups", "Aggregate Functions", "`Extent3D`"], "order": 41, "level": 4, "tokens": 158, "code_languages": ["python"], "links_out": [{"text": "PostGIS", "href": "https://postgis.net/docs/ST_3DExtent.md"}], "id": "dc2a0d0ea8e4e18b", "char_count": 1438}
{"content": "\nReturns the 3D extent of all `geo_field` in the `QuerySet` as a 6-tuple,\ncomprising the lower left coordinate and upper right coordinate (each with x, y,\nand z coordinates).\n\nExample:\n\n```python\n>>> qs = City.objects.filter(name__in=(\"Houston\", \"Dallas\")).aggregate(Extent3D(\"poly\"))\n>>> print(qs[\"poly__extent3d\"])\n(-96.8016128540039, 29.7633724212646, 0, -95.3631439208984, 32.782058715820, 0)\n```\n\n#### `MakeLine`\n\n`classMakeLine(geo_field,filter=None)`[[source]](https://github.com/django/django/blob/stable/5.2.x/django/contrib/gis/db/models/aggregates.py#L88)\n\n*Availability*: [PostGIS](https://postgis.net/docs/ST_MakeLine.md),\nSpatiaLite\n\nReturns a `LineString` constructed from the point field geometries in the\n`QuerySet`. Currently, ordering the queryset has no effect.\n\nExample:\n\n```python\n>>> qs = City.objects.filter(name__in=(\"Houston\", \"Dallas\")).aggregate(MakeLine(\"poly\"))\n>>> print(qs[\"poly__makeline\"])\nLINESTRING (-95.3631510000000020 29.7633739999999989, -96.8016109999999941 32.7820570000000018)\n```\n\n#### `Union`\n\n`classUnion(geo_field,filter=None)`[[source]](https://github.com/django/django/blob/stable/5.2.x/django/contrib/gis/db/models/aggregates.py#L93)\n\n*Availability*: [PostGIS](https://postgis.net/docs/ST_Union.md),\nOracle, SpatiaLite\n\nThis method returns a [`GEOSGeometry`](geos.md#django.contrib.gis.geos.GEOSGeometry) object\ncomprising the union of every geometry in the queryset. Please ", "source_file_id": "django__5_2__ref__contrib__gis__geoquerysets.html", "headings": ["the intersection pattern (the pattern here is for 'contains').", "Distance Lookups", "Aggregate Functions", "`MakeLine`"], "order": 42, "level": 4, "tokens": 155, "code_languages": ["python"], "links_out": [{"text": "PostGIS", "href": "https://postgis.net/docs/ST_MakeLine.md"}], "id": "03fa01665a6b482e", "char_count": 1425}
{"content": "akeLine.md),\nSpatiaLite\n\nReturns a `LineString` constructed from the point field geometries in the\n`QuerySet`. Currently, ordering the queryset has no effect.\n\nExample:\n\n```python\n>>> qs = City.objects.filter(name__in=(\"Houston\", \"Dallas\")).aggregate(MakeLine(\"poly\"))\n>>> print(qs[\"poly__makeline\"])\nLINESTRING (-95.3631510000000020 29.7633739999999989, -96.8016109999999941 32.7820570000000018)\n```\n\n#### `Union`\n\n`classUnion(geo_field,filter=None)`[[source]](https://github.com/django/django/blob/stable/5.2.x/django/contrib/gis/db/models/aggregates.py#L93)\n\n*Availability*: [PostGIS](https://postgis.net/docs/ST_Union.md),\nOracle, SpatiaLite\n\nThis method returns a [`GEOSGeometry`](geos.md#django.contrib.gis.geos.GEOSGeometry) object\ncomprising the union of every geometry in the queryset. Please note that use of\n`Union` is processor intensive and may take a significant amount of time on\nlarge querysets.\n\n> **NOTE:**\n>\n> If the computation time for using this method is too expensive, consider\n> using [`Collect`](#django.contrib.gis.db.models.Collect) instead.\n\nExample:\n\n```python\n>>> u = Zipcode.objects.aggregate(Union(poly))  # This may take a long time.\n>>> u = Zipcode.objects.filter(poly__within=bbox).aggregate(\n...     Union(poly)\n... )  # A more sensible approach.\n```\n\nFootnotes", "source_file_id": "django__5_2__ref__contrib__gis__geoquerysets.html", "headings": ["the intersection pattern (the pattern here is for 'contains').", "Distance Lookups", "Aggregate Functions", "`Union`"], "order": 43, "level": 4, "tokens": 224, "code_languages": ["python"], "links_out": [{"text": "PostGIS", "href": "https://postgis.net/docs/ST_Union.md"}, {"text": "`GEOSGeometry`", "href": "geos.md#django.contrib.gis.geos.GEOSGeometry"}, {"text": "`Collect`", "href": "#django.contrib.gis.db.models.Collect"}], "id": "a4094ff147a20d2c", "char_count": 1298}
