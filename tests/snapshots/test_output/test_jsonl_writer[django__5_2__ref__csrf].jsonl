{"content": "# Cross Site Request Forgery protection\n\nThe CSRF middleware and template tag provides easy-to-use protection against\n[Cross Site Request Forgeries](https://owasp.org/www-community/attacks/csrf#overview). This type of attack occurs when a malicious\nwebsite contains a link, a form button or some JavaScript that is intended to\nperform some action on your website, using the credentials of a logged-in user\nwho visits the malicious site in their browser. A related type of attack,\n\u2018login CSRF\u2019, where an attacking site tricks a user\u2019s browser into logging into\na site with someone else\u2019s credentials, is also covered.\n\nThe first defense against CSRF attacks is to ensure that GET requests (and other\n\u2018safe\u2019 methods, as defined by [**RFC 9110 Section 9.2.1**](https://datatracker.ietf.org/doc/html/rfc9110.md#section-9.2.1)) are side effect free.\nRequests via \u2018unsafe\u2019 methods, such as POST, PUT, and DELETE, can then be\nprotected by the steps outlined in [How to use Django\u2019s CSRF protection](../howto/csrf.md#using-csrf).\n\n## How it works\n\nThe CSRF protection is based on the following things:\n\n1. A CSRF cookie that is a random secret value, which other sites will not have\n   access to.\n\n   `CsrfViewMiddleware` sends this cookie with the response whenever\n   `django.middleware.csrf.get_token()` is called. It can also send it in\n   other cases. For security reasons, the value of the secret is changed each\n   time a us", "source_file_id": "django__5_2__ref__csrf.html", "headings": ["Cross Site Request Forgery protection"], "order": 0, "level": 1, "tokens": 255, "code_languages": [], "links_out": [{"text": "Cross Site Request Forgeries", "href": "https://owasp.org/www-community/attacks/csrf#overview"}, {"text": "**RFC 9110 Section 9.2.1**", "href": "https://datatracker.ietf.org/doc/html/rfc9110.md#section-9.2.1"}, {"text": "How to use Django\u2019s CSRF protection", "href": "../howto/csrf.md#using-csrf"}], "id": "b9c3c5a865c070a7", "char_count": 1423}
{"content": " first defense against CSRF attacks is to ensure that GET requests (and other\n\u2018safe\u2019 methods, as defined by [**RFC 9110 Section 9.2.1**](https://datatracker.ietf.org/doc/html/rfc9110.md#section-9.2.1)) are side effect free.\nRequests via \u2018unsafe\u2019 methods, such as POST, PUT, and DELETE, can then be\nprotected by the steps outlined in [How to use Django\u2019s CSRF protection](../howto/csrf.md#using-csrf).\n\n## How it works\n\nThe CSRF protection is based on the following things:\n\n1. A CSRF cookie that is a random secret value, which other sites will not have\n   access to.\n\n   `CsrfViewMiddleware` sends this cookie with the response whenever\n   `django.middleware.csrf.get_token()` is called. It can also send it in\n   other cases. For security reasons, the value of the secret is changed each\n   time a user logs in.\n2. A hidden form field with the name \u2018csrfmiddlewaretoken\u2019, present in all\n   outgoing POST forms.\n\n   In order to protect against [BREACH](https://www.breachattack.com/) attacks, the value of this field is\n   not simply the secret. It is scrambled differently with each response using\n   a mask. The mask is generated randomly on every call to `get_token()`, so\n   the form field value is different each time.\n\n   This part is done by the [`csrf_token`](templates/builtins.md#std-templatetag-csrf_token) template tag.\n3. For all incoming requests that are not using HTTP GET, HEAD, OPTIONS or\n   TRACE, a CSRF cookie must be present, and the \u2018csrfmiddlewaretoken\u2019 field\n   must be present and correct. If it isn\u2019t, the user will get a 403 error.\n\n   When validating the \u2018csrfmiddlewaretoken\u2019 field value, only the secret,\n   not the full token, is compared with the secret in the cookie value.\n   This allows the use of ever-changing tokens. While each request may use its\n   own token, the secret remains common to all.\n\n   This check is done by `CsrfViewMiddleware`.\n4. `CsrfViewMiddleware` verifies the [Origin header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Origin), if provided by the\n   browser, against the current host and the [`CSRF_TRUSTED_ORIGINS`](settings.md#std-setting-CSRF_TRUSTED_ORIGINS)\n   setting. This provides protection against cross-subdomain attacks.\n5. In addition, for HTTPS requests, if the `Origin` header isn\u2019t provided,\n   `CsrfViewMiddleware` performs strict referer checking. This means that\n   even if a subdomain can set or modify cookies on your domain, it can\u2019t force\n   a user to post to your application since that request won\u2019t come from your\n   own exact domain.\n\n   This also addresses a man-in-the-middle attack that\u2019s possible under HTTPS\n   when using a session independent secret, due to the fact that HTTP\n   `Set-Cookie` headers are (unfortunately) accepted by clients even when\n   they are talking to a site under HTTPS. (Referer checking is not done for\n   HTTP requests because the presence of the `Referer` header isn\u2019t reliable\n   enough under HTTP.)\n\n   If the [`CSRF_COOKIE_DOMAIN`](settings.md#std-setting-CSRF_COOKIE_DOMAIN) setting is set, the referer is compared\n   against it. You can allow cross-subdomain requests by including a leading\n   dot. For example, `CSRF_COOKIE_DOMAIN = '.example.com'` will allow POST\n   requests from `www.example.com` and `api.example.com`. If the setting is\n   not set, then the referer must match the HTTP `Host` header.\n\n   Expanding the accepted referers beyond the current host or cookie domain can\n   be done with the [`CSRF_TRUSTED_ORIGINS`](settings.md#std-setting-CSRF_TRUSTED_ORIGINS) setting.\n\nThis ensures that only forms that have originated from trusted domains can be\nused to POST data back.\n\nIt deliberately ignores GET requests (and other requests that are defined as\n\u2018safe\u2019 by [**RFC 9110 Section 9.2.1**](https://datatracker.ietf.org/doc/html/rfc9110.md#section-9.2.1)). These requests ought never to have any\npotentially dangerous side effects, and so a CSRF attack with a GET request\nought to be harmless. [**RFC 9110 Section 9.2.1**](https://datatracker.ietf.org/doc/html/rfc9110.md#section-9.2.1) defines POST, PUT, and DELETE\nas \u2018unsafe\u2019, and all other methods are also assumed to be unsafe, for maximum\nprotection.\n\nThe CSRF protection cannot protect against man-in-the-middle attacks, so use\n[HTTPS](../topics/security.md#security-recommendation-ssl) with\n[HTTP Strict Transport Security](middleware.md#http-strict-transport-security). It also assumes [validation of\nthe HOST header](../topics/security.md#host-headers-virtual-hosting) and that there aren\u2019t any\n[cross-site scripting vulnerabilities](../topics/secu", "source_file_id": "django__5_2__ref__csrf.html", "headings": ["Cross Site Request Forgery protection", "How it works"], "order": 1, "level": 2, "tokens": 940, "code_languages": [], "links_out": [], "id": "37f3689fed868c93", "char_count": 4565}
{"content": "cker.ietf.org/doc/html/rfc9110.md#section-9.2.1)). These requests ought never to have any\npotentially dangerous side effects, and so a CSRF attack with a GET request\nought to be harmless. [**RFC 9110 Section 9.2.1**](https://datatracker.ietf.org/doc/html/rfc9110.md#section-9.2.1) defines POST, PUT, and DELETE\nas \u2018unsafe\u2019, and all other methods are also assumed to be unsafe, for maximum\nprotection.\n\nThe CSRF protection cannot protect against man-in-the-middle attacks, so use\n[HTTPS](../topics/security.md#security-recommendation-ssl) with\n[HTTP Strict Transport Security](middleware.md#http-strict-transport-security). It also assumes [validation of\nthe HOST header](../topics/security.md#host-headers-virtual-hosting) and that there aren\u2019t any\n[cross-site scripting vulnerabilities](../topics/security.md#cross-site-scripting) on your site\n(because XSS vulnerabilities already let an attacker do anything a CSRF\nvulnerability allows and much worse).\n\n> **NOTE:**\n>\n> To avoid disclosing the referrer URL to third-party sites, you might want\n> to [disable the referer](https://www.w3.org/TR/referrer-policy/#referrer-policy-delivery) on your site\u2019s `<a>` tags. For example, you\n> might use the `<meta name=\"referrer\" content=\"no-referrer\">` tag or\n> include the `Referrer-Policy: no-referrer` header. Due to the CSRF\n> protection\u2019s strict referer checking on HTTPS requests, those techniques\n> cause a CSRF failure on requests with \u2018unsafe\u2019 methods. Instead, use\n> alternatives like `<a rel=\"noreferrer\" ...>\"` for links to third-party\n> sites.\n\n## Limitations\n\nSubdomains within a site will be able to set cookies on the client for the whole\ndomain. By setting the cookie and using a corresponding token, subdomains will\nbe able to circumvent the CSRF protection. The only way to avoid this is to\nensure that subdomains are controlled by trusted users (or, are at least unable\nto set cookies). Note that even without CSRF, there are other vulner", "source_file_id": "django__5_2__ref__csrf.html", "headings": ["Cross Site Request Forgery protection", "How it works"], "order": 2, "level": 2, "tokens": 286, "code_languages": [], "links_out": [], "id": "783af9e1b4547aa6", "char_count": 1950}
{"content": "te\u2019s `<a>` tags. For example, you\n> might use the `<meta name=\"referrer\" content=\"no-referrer\">` tag or\n> include the `Referrer-Policy: no-referrer` header. Due to the CSRF\n> protection\u2019s strict referer checking on HTTPS requests, those techniques\n> cause a CSRF failure on requests with \u2018unsafe\u2019 methods. Instead, use\n> alternatives like `<a rel=\"noreferrer\" ...>\"` for links to third-party\n> sites.\n\n## Limitations\n\nSubdomains within a site will be able to set cookies on the client for the whole\ndomain. By setting the cookie and using a corresponding token, subdomains will\nbe able to circumvent the CSRF protection. The only way to avoid this is to\nensure that subdomains are controlled by trusted users (or, are at least unable\nto set cookies). Note that even without CSRF, there are other vulnerabilities,\nsuch as session fixation, that make giving subdomains to untrusted parties a bad\nidea, and these vulnerabilities cannot easily be fixed with current browsers.\n\n## Utilities\n\nThe examples below assume you are using function-based views. If you\nare working with class-based views, you can refer to [Decorating\nclass-based views](../topics/class-based-views/intro.md#id1).\n\n`csrf_exempt(view)`[[source]](https://github.com/django/django/blob/stable/5.2.x/django/views/decorators/csrf.py#L51)\n:   This decorator marks a view as being exempt from the protection ens", "source_file_id": "django__5_2__ref__csrf.html", "headings": ["Cross Site Request Forgery protection", "Limitations"], "order": 3, "level": 2, "tokens": 142, "code_languages": [], "links_out": [], "id": "16bc78486e6c2cb1", "char_count": 1373}
{"content": "s will\nbe able to circumvent the CSRF protection. The only way to avoid this is to\nensure that subdomains are controlled by trusted users (or, are at least unable\nto set cookies). Note that even without CSRF, there are other vulnerabilities,\nsuch as session fixation, that make giving subdomains to untrusted parties a bad\nidea, and these vulnerabilities cannot easily be fixed with current browsers.\n\n## Utilities\n\nThe examples below assume you are using function-based views. If you\nare working with class-based views, you can refer to [Decorating\nclass-based views](../topics/class-based-views/intro.md#id1).\n\n`csrf_exempt(view)`[[source]](https://github.com/django/django/blob/stable/5.2.x/django/views/decorators/csrf.py#L51)\n:   This decorator marks a view as being exempt from the protection ensured by\n    the middleware. Example:\n\n    ```python\n    from django.http import HttpResponse\n    from django.views.decorators.csrf import csrf_exempt\n\n\n    @csrf_exempt\n    def my_view(request):\n        return HttpResponse(\"Hello world\")\n    ```\n\n`csrf_protect(view)`\n:   Decorator that provides the protection of\n    [`CsrfViewMiddleware`](middleware.md#django.middleware.csrf.CsrfViewMiddleware) to a view.\n\n    Usage:\n\n    ```python\n    from django.shortcuts import render\n    from django.views.decorators.csrf import csrf_protect\n\n\n    @csrf_protect\n    def my_view(request):\n        c = {}\n        # ...\n        return render(request, \"a_template.html\", c)\n    ```\n\n`requires_csrf_token(view)`\n:   Normally the [`csrf_token`](templates/builtins.md#std-templatetag-csrf_token) template tag will not work if\n    `CsrfViewMiddleware.process_view` or an equivalent like `csrf_protect`\n    has not run. The view decorator `requires_csrf_token` can be used to\n    ensure the template tag does work. This decorator works similarly to\n    `csrf_protect`, but never rejects an incoming request.\n\n    Example:\n\n    ```python\n    from django.shortcuts import render\n    from django.views.decorators.csrf import requires_csrf_token\n\n\n    @requires_csrf_token\n    def my_view(request):\n        c = {}\n        # ...\n        return render(request, \"a_template.html\", c)\n    ```\n\n`ensure_csrf_cookie(view)`\n:   This decorator forces a view to send the CSRF cookie.\n\n## Settings\n\nA number of settings can be used to control Django\u2019s CSRF behavior:\n\n- [`CSRF_COOKIE_AGE`](settings.md#std-setting-CSRF_COOKIE_AGE)\n- [`CSRF_COOKIE_DOMAIN`](settings.md#std-setting-CSRF_COOKIE_DOMAIN)\n- [`CSRF_COOKIE_HTTPONLY`](settings.md#std-setting-CSRF_COOKIE_HTTPONLY)\n- [`CSRF_COOKIE_NAME`](settings.md#std-setting-CSRF_COOKIE_NAME)\n- [`CSRF_COOKIE_PATH`](settings.md#std-setting-C", "source_file_id": "django__5_2__ref__csrf.html", "headings": ["Cross Site Request Forgery protection", "Utilities"], "order": 4, "level": 2, "tokens": 463, "code_languages": [], "links_out": [{"text": "Decorating\nclass-based views", "href": "../topics/class-based-views/intro.md#id1"}, {"text": "`CsrfViewMiddleware`", "href": "middleware.md#django.middleware.csrf.CsrfViewMiddleware"}, {"text": "`csrf_token`", "href": "templates/builtins.md#std-templatetag-csrf_token"}], "id": "7ec2ef6fe3869c1d", "char_count": 2657}
{"content": "ut never rejects an incoming request.\n\n    Example:\n\n    ```python\n    from django.shortcuts import render\n    from django.views.decorators.csrf import requires_csrf_token\n\n\n    @requires_csrf_token\n    def my_view(request):\n        c = {}\n        # ...\n        return render(request, \"a_template.html\", c)\n    ```\n\n`ensure_csrf_cookie(view)`\n:   This decorator forces a view to send the CSRF cookie.\n\n## Settings\n\nA number of settings can be used to control Django\u2019s CSRF behavior:\n\n- [`CSRF_COOKIE_AGE`](settings.md#std-setting-CSRF_COOKIE_AGE)\n- [`CSRF_COOKIE_DOMAIN`](settings.md#std-setting-CSRF_COOKIE_DOMAIN)\n- [`CSRF_COOKIE_HTTPONLY`](settings.md#std-setting-CSRF_COOKIE_HTTPONLY)\n- [`CSRF_COOKIE_NAME`](settings.md#std-setting-CSRF_COOKIE_NAME)\n- [`CSRF_COOKIE_PATH`](settings.md#std-setting-CSRF_COOKIE_PATH)\n- [`CSRF_COOKIE_SAMESITE`](settings.md#std-setting-CSRF_COOKIE_SAMESITE)\n- [`CSRF_COOKIE_SECURE`](settings.md#std-setting-CSRF_COOKIE_SECURE)\n- [`CSRF_FAILURE_VIEW`](settings.md#std-setting-CSRF_FAILURE_VIEW)\n- [`CSRF_HEADER_NAME`](settings.md#std-setting-CSRF_HEADER_NAME)\n- [`CSRF_TRUSTED_ORIGINS`](settings.md#std-setting-CSRF_TRUSTED_ORIGINS)\n- [`CSRF_USE_SESSIONS`](settings.md#std-setting-CSRF_USE_SESSIONS)\n\n## Frequently Asked Questions\n\n### Is posting an arbitrary CSRF token pair (cookie and POST data) a vulnerability?\n\nNo, this is by design. Without a man-in-the-middle attack, there is no way for\nan attacker to send a CSRF token cookie to a victim\u2019s browser, so a successful\nattack would need to obtain the victim\u2019s browser\u2019s cookie via XSS or similar,\nin which case an attacker usually doesn\u2019t need C", "source_file_id": "django__5_2__ref__csrf.html", "headings": ["Cross Site Request Forgery protection", "Settings"], "order": 5, "level": 2, "tokens": 207, "code_languages": [], "links_out": [{"text": "`CSRF_COOKIE_AGE`", "href": "settings.md#std-setting-CSRF_COOKIE_AGE"}, {"text": "`CSRF_COOKIE_DOMAIN`", "href": "settings.md#std-setting-CSRF_COOKIE_DOMAIN"}, {"text": "`CSRF_COOKIE_HTTPONLY`", "href": "settings.md#std-setting-CSRF_COOKIE_HTTPONLY"}, {"text": "`CSRF_COOKIE_NAME`", "href": "settings.md#std-setting-CSRF_COOKIE_NAME"}, {"text": "`CSRF_COOKIE_PATH`", "href": "settings.md#std-setting-CSRF_COOKIE_PATH"}, {"text": "`CSRF_COOKIE_SAMESITE`", "href": "settings.md#std-setting-CSRF_COOKIE_SAMESITE"}, {"text": "`CSRF_COOKIE_SECURE`", "href": "settings.md#std-setting-CSRF_COOKIE_SECURE"}, {"text": "`CSRF_FAILURE_VIEW`", "href": "settings.md#std-setting-CSRF_FAILURE_VIEW"}, {"text": "`CSRF_HEADER_NAME`", "href": "settings.md#std-setting-CSRF_HEADER_NAME"}, {"text": "`CSRF_TRUSTED_ORIGINS`", "href": "settings.md#std-setting-CSRF_TRUSTED_ORIGINS"}, {"text": "`CSRF_USE_SESSIONS`", "href": "settings.md#std-setting-CSRF_USE_SESSIONS"}], "id": "8e555ca8d4d7b958", "char_count": 1634}
{"content": "IE_SAMESITE`](settings.md#std-setting-CSRF_COOKIE_SAMESITE)\n- [`CSRF_COOKIE_SECURE`](settings.md#std-setting-CSRF_COOKIE_SECURE)\n- [`CSRF_FAILURE_VIEW`](settings.md#std-setting-CSRF_FAILURE_VIEW)\n- [`CSRF_HEADER_NAME`](settings.md#std-setting-CSRF_HEADER_NAME)\n- [`CSRF_TRUSTED_ORIGINS`](settings.md#std-setting-CSRF_TRUSTED_ORIGINS)\n- [`CSRF_USE_SESSIONS`](settings.md#std-setting-CSRF_USE_SESSIONS)\n\n## Frequently Asked Questions\n\n### Is posting an arbitrary CSRF token pair (cookie and POST data) a vulnerability?\n\nNo, this is by design. Without a man-in-the-middle attack, there is no way for\nan attacker to send a CSRF token cookie to a victim\u2019s browser, so a successful\nattack would need to obtain the victim\u2019s browser\u2019s cookie via XSS or similar,\nin which case an attacker usually doesn\u2019t need CSRF attacks.\n\nSome security audit tools flag this as a problem but as mentioned before, an\nattacker cannot steal a user\u2019s browser\u2019s CSRF cookie. \u201cStealing\u201d or modifying\n*your own* token using Firebug, Chrome dev tools, etc. isn\u2019t a vulnerability.\n\n\n\n### Is it a problem that Django\u2019s CSRF protection isn\u2019t linked to a session by default?\n\nNo, this is by design. Not linking CSRF protection to a session allows using\nthe protection on sites such as a *pastebin* that allow submissions from\nanonymous users which don\u2019t have a session.\n\nIf you wish to store the CSRF token in the user\u2019s session, use the\n[`CSRF_USE_SESSIONS`](settings.md#std-setting-CSRF_USE_SESSIONS) setting.\n\n\n\n### Why might a user encounter a CSRF validation failure after logging in?\n\nFor security reasons, CSRF tokens are rotated each time a user logs in. Any\npage with a form generated before a login will have an old, invalid CSRF token\nand need to be reloaded. This might happen if a user uses the back button after\na login or if they log in a different browser tab.", "source_file_id": "django__5_2__ref__csrf.html", "headings": ["Cross Site Request Forgery protection", "Frequently Asked Questions"], "order": 6, "level": 2, "tokens": 359, "code_languages": [], "links_out": [], "id": "161a29a9b2d08568", "char_count": 1841}
