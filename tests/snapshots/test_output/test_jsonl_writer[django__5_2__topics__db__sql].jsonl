{"content": "# Performing raw SQL queries\n\nDjango gives you two ways of performing raw SQL queries: you can use\n[`Manager.raw()`](#django.db.models.Manager.raw) to [perform raw queries and return model instances](#performing-raw-queries), or\nyou can avoid the model layer entirely and [execute custom SQL directly](#executing-custom-sql-directly).\n\n> **NOTE:**\n>\n> The Django ORM provides many tools to express queries without writing raw\n> SQL. For example:\n>\n> - The [QuerySet API](../../ref/models/querysets.md) is extensive.\n> - You can [`annotate`](../../ref/models/querysets.md#django.db.models.query.QuerySet.annotate) and [aggregate](aggregation.md) using many built-in [database functions](../../ref/models/database-functions.md). Beyond those, you can create\n>   [custom query expressions](../../ref/models/expressions.md).\n>\n> Before using raw SQL, explore [the ORM](index.md). Ask on\n> one of [the support channels](../../faq/help.md) to see if the ORM supports\n> your use case.\n\n> **WARNING:**\n>\n> You should be very careful whenever you write raw SQL. Every time you use\n> it, you should properly escape any parameters that the user can control\n> by using `params` in order to protect against SQL injection attacks.\n> Please read more about [SQL injection protection](../security.md#sql-injection-protection).\n\n## Performing raw queries\n\nThe `raw()` manager method can be used to perform raw SQL queries that\nreturn model instances:\n\n`Manager.raw(raw_query,params=(),translations=None)`\n\nThis method takes a raw SQL query, executes it, and returns a\n`django.db.models.query.RawQuerySet` instance. This `RawQuerySet` instance\ncan be iterated over like a normal [`QuerySet`](../../ref/models/querysets.md#django.d", "source_file_id": "django__5_2__topics__db__sql.html", "headings": ["Performing raw SQL queries"], "order": 0, "level": 1, "tokens": 327, "code_languages": ["python"], "links_out": [{"text": "`Manager.raw()`", "href": "#django.db.models.Manager.raw"}, {"text": "perform raw queries and return model instances", "href": "#performing-raw-queries"}, {"text": "execute custom SQL directly", "href": "#executing-custom-sql-directly"}, {"text": "QuerySet API", "href": "../../ref/models/querysets.md"}, {"text": "`annotate`", "href": "../../ref/models/querysets.md#django.db.models.query.QuerySet.annotate"}, {"text": "aggregate", "href": "aggregation.md"}, {"text": "database functions", "href": "../../ref/models/database-functions.md"}, {"text": "custom query expressions", "href": "../../ref/models/expressions.md"}, {"text": "the ORM", "href": "index.md"}, {"text": "the support channels", "href": "../../faq/help.md"}, {"text": "SQL injection protection", "href": "../security.md#sql-injection-protection"}], "id": "77f58af7e5191921", "char_count": 1712}
{"content": "els](../../faq/help.md) to see if the ORM supports\n> your use case.\n\n> **WARNING:**\n>\n> You should be very careful whenever you write raw SQL. Every time you use\n> it, you should properly escape any parameters that the user can control\n> by using `params` in order to protect against SQL injection attacks.\n> Please read more about [SQL injection protection](../security.md#sql-injection-protection).\n\n## Performing raw queries\n\nThe `raw()` manager method can be used to perform raw SQL queries that\nreturn model instances:\n\n`Manager.raw(raw_query,params=(),translations=None)`\n\nThis method takes a raw SQL query, executes it, and returns a\n`django.db.models.query.RawQuerySet` instance. This `RawQuerySet` instance\ncan be iterated over like a normal [`QuerySet`](../../ref/models/querysets.md#django.db.models.query.QuerySet) to\nprovide object instances.\n\nThis is best illustrated with an example. Suppose you have the following model:\n\n```python\nclass Person(models.Model):\n    first_name = models.CharField(...)\n    last_name = models.CharField(...)\n    birth_date = models.DateField(...)\n```\n\nYou could then execute custom SQL like so:\n\n```python\n>>> for p in Person.objects.raw(\"SELECT * FROM myapp_person\"):\n...     print(p)\n...\nJohn Smith\nJane Jones\n```\n\nThis example isn\u2019t very exciting \u2013 it\u2019s exactly the same as running\n`Person.objects.all()`. However, `raw()` has a bunch of other options that\nmake it very powerful.\n\n> **NOTE:**\n>\n> Where did the name of the `Person` table come from in that example?\n>\n> By default, Django figures out a database table name by joining the\n> model\u2019s \u201capp label\u201d \u2013 the name you used in `manage.py startapp` \u2013 to\n> the model\u2019s class name, with an underscore between them. In the example\n> we\u2019ve assumed that the `Person` model lives in an app named `myapp`,\n> so its table would be `myapp_person`.\n>\n> For more details check out the documentation for the\n> [`db_table`](../../ref/models/options.md#django.db.models.Options.db_table) option, which also lets you manually set the\n> database table name.\n\n> **WARNING:**\n>\n> No checking is done on the SQL statement that is passed in to `.raw()`.\n> Django expects that the statement will return a set of rows from the\n> database, but does nothing to enforce that. If the query does not\n> return rows, a (possibly cryptic) error will result.\n\n> **WARNING:**\n>\n> If you are performing queries on MySQL, note that MySQL\u2019s silent type coercion\n> may cause unexpected results when mixing types. If you query on a string\n> type column, but with an integer value, MySQL will coerce the types of all values\n> in the table to an integer before performing the comparison. For example, if your\n> table contains the values `'abc'`, `'def'` and you query for `WHERE mycolumn=0`,\n> both rows will match. To prevent this, perform the correct typecasting\n> before using the value in a query.\n\n### Mapping query fields to model fields\n\n`raw()` automatically maps fields in the query to fields on the model.\n\nThe order of fields in your query doesn\u2019t matter. In other words, both\nof the following queries work identically:\n\n```python\n>>> Person.objects.raw(\"SELECT id, first_name, last_name, birth_date FROM myapp_person\")\n>>> Person.objects.raw(\"SELECT last_name, birth_date, first_name, id FRO", "source_file_id": "django__5_2__topics__db__sql.html", "headings": ["Performing raw SQL queries", "Performing raw queries"], "order": 1, "level": 2, "tokens": 615, "code_languages": ["python"], "links_out": [{"text": "`QuerySet`", "href": "../../ref/models/querysets.md#django.db.models.query.QuerySet"}, {"text": "`db_table`", "href": "../../ref/models/options.md#django.db.models.Options.db_table"}], "id": "8d7f7f6f6c5f63d2", "char_count": 3266}
{"content": " mixing types. If you query on a string\n> type column, but with an integer value, MySQL will coerce the types of all values\n> in the table to an integer before performing the comparison. For example, if your\n> table contains the values `'abc'`, `'def'` and you query for `WHERE mycolumn=0`,\n> both rows will match. To prevent this, perform the correct typecasting\n> before using the value in a query.\n\n### Mapping query fields to model fields\n\n`raw()` automatically maps fields in the query to fields on the model.\n\nThe order of fields in your query doesn\u2019t matter. In other words, both\nof the following queries work identically:\n\n```python\n>>> Person.objects.raw(\"SELECT id, first_name, last_name, birth_date FROM myapp_person\")\n>>> Person.objects.raw(\"SELECT last_name, birth_date, first_name, id FROM myapp_person\")\n```\n\nMatching is done by name. This means that you can use SQL\u2019s `AS` clauses to\nmap fields in the query to model fields. So if you had some other table that\nhad `Person` data in it, you could easily map it into `Person` instances:\n\n```python\n>>> Person.objects.raw(\n...     \"\"\"\n...     SELECT first AS first_name,\n...            last AS last_name,\n...            bd AS birth_date,\n...            pk AS id,\n...     FROM some_other_table\n...     \"\"\"\n... )\n```\n\nAs long as the names match, the model instances will be created correctly.\n\nAlternatively, you can map fields in the query to model fields using the\n`translations` argument to `raw()`. This is a dictionary mapping names of\nfields in the query to names of fields on the model. For example, the above\nquery could also be written:\n\n```python\n>>> name_map = {\"first\": \"first_name\", \"last\": \"last_name\", \"bd\": \"birth_date\", \"pk\": \"id\"}\n>>> Person.objects.raw(\"SELECT * FROM some_other_table\", translations=name_map)\n```\n\n### Index lookups\n\n`raw()` supports indexing, so if you need only the first result you can\nwrite:\n\n```python\n>>> first_person = Person.objects.raw(\"SELECT * FROM myapp_person\")[0]\n```\n\nHowever, the indexing and slicing are not performed at the database level. If\nyou have a large number of `Person` objects in your database, it is more\nefficient to limit the query at the SQL level:\n\n```python\n>>> fi", "source_file_id": "django__5_2__topics__db__sql.html", "headings": ["Performing raw SQL queries", "Performing raw queries", "Mapping query fields to model fields"], "order": 2, "level": 3, "tokens": 347, "code_languages": ["python"], "links_out": [], "id": "962757cebb2d0b2b", "char_count": 2195}
{"content": "he query to model fields using the\n`translations` argument to `raw()`. This is a dictionary mapping names of\nfields in the query to names of fields on the model. For example, the above\nquery could also be written:\n\n```python\n>>> name_map = {\"first\": \"first_name\", \"last\": \"last_name\", \"bd\": \"birth_date\", \"pk\": \"id\"}\n>>> Person.objects.raw(\"SELECT * FROM some_other_table\", translations=name_map)\n```\n\n### Index lookups\n\n`raw()` supports indexing, so if you need only the first result you can\nwrite:\n\n```python\n>>> first_person = Person.objects.raw(\"SELECT * FROM myapp_person\")[0]\n```\n\nHowever, the indexing and slicing are not performed at the database level. If\nyou have a large number of `Person` objects in your database, it is more\nefficient to limit the query at the SQL level:\n\n```python\n>>> first_person = Person.objects.raw(\"SELECT * FROM myapp_person LIMIT 1\")[0]\n```\n\n### Deferring model fields\n\nFields may also be left out:\n\n```python\n>>> people = Person.objects.raw(\"SELECT id, first_name FROM myapp_person\")\n```\n\nThe `Person` objects returned by this query will be deferred model instances\n(see [`defer()`](../../ref/models/querysets.md#django.db.models.query.QuerySet.defer)). This means that the\nfields that are omitted from the query will be loaded on demand. Fo", "source_file_id": "django__5_2__topics__db__sql.html", "headings": ["Performing raw SQL queries", "Performing raw queries", "Index lookups"], "order": 3, "level": 3, "tokens": 119, "code_languages": ["python"], "links_out": [], "id": "f1377087a6bdb3dc", "char_count": 1280}
{"content": "result you can\nwrite:\n\n```python\n>>> first_person = Person.objects.raw(\"SELECT * FROM myapp_person\")[0]\n```\n\nHowever, the indexing and slicing are not performed at the database level. If\nyou have a large number of `Person` objects in your database, it is more\nefficient to limit the query at the SQL level:\n\n```python\n>>> first_person = Person.objects.raw(\"SELECT * FROM myapp_person LIMIT 1\")[0]\n```\n\n### Deferring model fields\n\nFields may also be left out:\n\n```python\n>>> people = Person.objects.raw(\"SELECT id, first_name FROM myapp_person\")\n```\n\nThe `Person` objects returned by this query will be deferred model instances\n(see [`defer()`](../../ref/models/querysets.md#django.db.models.query.QuerySet.defer)). This means that the\nfields that are omitted from the query will be loaded on demand. For example:\n\n```python\n>>> for p in Person.objects.raw(\"SELECT id, first_name FROM myapp_person\"):\n...     print(\n...         p.first_name,  # This will be retrieved by the original query\n...         p.last_name,  # This will be retrieved on demand\n...     )\n...\nJohn Smith\nJane Jones\n```\n\nFrom outward appearances, this looks like the query has retrieved both\nthe first name and last name. However, this example actually issued 3\nqueries. Only the first names were retrieved by the `raw()` query \u2013 the\nlast names were both retrieved on demand when they were printed.\n\nThere is only one field that you can\u2019t leave out - the primary key\nfield. Django uses the primary key to identify model instances, so it\nmust always be included in a raw query. A\n[`FieldDoesNotExist`](../../ref/exceptions.md#django.core.exceptions.FieldDoesNotExist) exception will be raised if\nyou forget to include the primary key.\n\n### Adding annotations\n\nYou can also execute queries containing fields that aren\u2019t defined on the\nmodel. For example, we could use [PostgreSQL\u2019s age() function](https://www.postgresql.org/docs/current/functions-datetime.md) to get a list\nof people with their ages calculated by the database:\n\n```python\n>>> people = Person.objects.raw(\"SELECT *, age(birth_date) AS age FROM myapp_person\")\n>>> for p ", "source_file_id": "django__5_2__topics__db__sql.html", "headings": ["Performing raw SQL queries", "Performing raw queries", "Deferring model fields"], "order": 4, "level": 3, "tokens": 325, "code_languages": ["python"], "links_out": [{"text": "`defer()`", "href": "../../ref/models/querysets.md#django.db.models.query.QuerySet.defer"}, {"text": "`FieldDoesNotExist`", "href": "../../ref/exceptions.md#django.core.exceptions.FieldDoesNotExist"}], "id": "25d2749aef20e17f", "char_count": 2104}
{"content": "\nlast names were both retrieved on demand when they were printed.\n\nThere is only one field that you can\u2019t leave out - the primary key\nfield. Django uses the primary key to identify model instances, so it\nmust always be included in a raw query. A\n[`FieldDoesNotExist`](../../ref/exceptions.md#django.core.exceptions.FieldDoesNotExist) exception will be raised if\nyou forget to include the primary key.\n\n### Adding annotations\n\nYou can also execute queries containing fields that aren\u2019t defined on the\nmodel. For example, we could use [PostgreSQL\u2019s age() function](https://www.postgresql.org/docs/current/functions-datetime.md) to get a list\nof people with their ages calculated by the database:\n\n```python\n>>> people = Person.objects.raw(\"SELECT *, age(birth_date) AS age FROM myapp_person\")\n>>> for p in people:\n...     print(\"%s is %s.\" % (p.first_name, p.age))\n...\nJohn is 37.\nJane is 42.\n...\n```\n\nYou can often avoid using raw SQL to compute annotations by instead using a\n[Func() expression](../../ref/models/expressions.md#func-expressions).\n\n### Passing parameters into `raw()`\n\nIf you need to perform parameterized queries, you can use the `params`\nargument to `raw()`:\n\n```python\n>>> lname = \"Doe\"\n>>> Person.objects.raw(\"SELECT * FROM myapp_person WHERE last_name = %s\", [lname])\n```\n\n`params` is a list or dictionary of parameters. You\u2019ll use `%s`\nplaceholders in the query string for a list, or `%(key)s`\nplaceholders for a dictionary (w", "source_file_id": "django__5_2__topics__db__sql.html", "headings": ["Performing raw SQL queries", "Performing raw queries", "Adding annotations"], "order": 5, "level": 3, "tokens": 161, "code_languages": ["python"], "links_out": [{"text": "PostgreSQL\u2019s age() function", "href": "https://www.postgresql.org/docs/current/functions-datetime.md"}, {"text": "Func() expression", "href": "../../ref/models/expressions.md#func-expressions"}], "id": "3a0331a217928775", "char_count": 1448}
{"content": "le with their ages calculated by the database:\n\n```python\n>>> people = Person.objects.raw(\"SELECT *, age(birth_date) AS age FROM myapp_person\")\n>>> for p in people:\n...     print(\"%s is %s.\" % (p.first_name, p.age))\n...\nJohn is 37.\nJane is 42.\n...\n```\n\nYou can often avoid using raw SQL to compute annotations by instead using a\n[Func() expression](../../ref/models/expressions.md#func-expressions).\n\n### Passing parameters into `raw()`\n\nIf you need to perform parameterized queries, you can use the `params`\nargument to `raw()`:\n\n```python\n>>> lname = \"Doe\"\n>>> Person.objects.raw(\"SELECT * FROM myapp_person WHERE last_name = %s\", [lname])\n```\n\n`params` is a list or dictionary of parameters. You\u2019ll use `%s`\nplaceholders in the query string for a list, or `%(key)s`\nplaceholders for a dictionary (where `key` is replaced by a\ndictionary key), regardless of your database engine. Such placeholders will be\nreplaced with parameters from the `params` argument.\n\n> **NOTE:**\n>\n> Dictionary params are not supported with the SQLite backend; with\n> this backend, you must pass parameters as a list.\n\n> **WARNING:**\n>\n> **Do not use string formatting on raw queries or quote placeholders in your\n> SQL strings!**\n>\n> It\u2019s tempting to write the above query as:\n>\n> ```python\n> >>> query = \"SELECT * FROM myapp_person WHERE last_name = %s\" % lname\n> >>> Person.objects.raw(query)\n> ```\n>\n> You might also think you should write your query like this (with quotes\n> around `%s`):\n>\n> ```python\n> >>> query = \"SELECT * FROM myapp_person WHERE last_name = '%s'\"\n> ```\n>\n> **Don\u2019t make either of these mistakes.**\n>\n> As discussed in [SQL injection protection](../security.md#sql-injection-protection), using the `params`\n> argument and leaving the placeholders unquoted protects you from [SQL\n> injection attacks](https://en.wikipedia.org/wiki/SQL_injection), a common exploit where attackers inject arbitrary\n> SQL into your database. If you use string interpolation or quote the\n> placeholder, you\u2019re at risk for SQL injection.\n\n## Executing custom SQL directly\n\nSometimes even [`Manager.raw()`](#django.db.models.Manager.raw) isn\u2019t quite enough: you might need to\nperform queries that don\u2019t map cleanly to models, or directly execute\n`UPDATE`, `INSERT`, or `DELETE` queries.\n\nIn these cases, you can always access the database directly, routing around\nthe model layer entirely.\n\nThe object `django.db.connection` represents the ", "source_file_id": "django__5_2__topics__db__sql.html", "headings": ["Performing raw SQL queries", "Performing raw queries", "Passing parameters into `raw()`"], "order": 6, "level": 3, "tokens": 404, "code_languages": ["python"], "links_out": [{"text": "SQL injection protection", "href": "../security.md#sql-injection-protection"}, {"text": "SQL\n> injection attacks", "href": "https://en.wikipedia.org/wiki/SQL_injection"}], "id": "7c429ce3c772a3bf", "char_count": 2421}
{"content": " in [SQL injection protection](../security.md#sql-injection-protection), using the `params`\n> argument and leaving the placeholders unquoted protects you from [SQL\n> injection attacks](https://en.wikipedia.org/wiki/SQL_injection), a common exploit where attackers inject arbitrary\n> SQL into your database. If you use string interpolation or quote the\n> placeholder, you\u2019re at risk for SQL injection.\n\n## Executing custom SQL directly\n\nSometimes even [`Manager.raw()`](#django.db.models.Manager.raw) isn\u2019t quite enough: you might need to\nperform queries that don\u2019t map cleanly to models, or directly execute\n`UPDATE`, `INSERT`, or `DELETE` queries.\n\nIn these cases, you can always access the database directly, routing around\nthe model layer entirely.\n\nThe object `django.db.connection` represents the default database\nconnection. To use the database connection, call `connection.cursor()` to\nget a cursor object. Then, call `cursor.execute(sql, [params])` to execute\nthe SQL and `cursor.fetchone()` or `cursor.fetchall()` to return the\nresulting rows.\n\nFor example:\n\n```python\nfrom django.db import connection\n\n\ndef my_custom_sql(self):\n    with connection.cursor() as cursor:\n        cursor.execute(\"UPDATE bar SET foo = 1 WHERE baz = %s\", [self.baz])\n        cursor.execute(\"SELECT foo FROM bar WHERE baz = %s\", [self.baz])\n        row = cursor.fetchone()\n\n    return row\n```\n\nTo protect against SQL injection, you must not include quotes around the `%s`\nplaceholders in the SQL string.\n\nNote that if you want to include literal percent signs in the query, you have to\ndouble them in the case you are passing parameters:\n\n```python\ncursor.execute(\"SELECT foo FROM bar WHERE baz = '30%'\")\ncursor.execute(\"SELECT foo FROM bar WHERE baz = '30%%' AND id = %s\", [self.id])\n```\n\nIf you are using [more than one database](multi-db.md), you can\nuse `django.db.connections` to obtain the connection (and cursor) for a\nspecific database. `django.db.connections` is a dictionary-like\nobject that allows you to retrieve a specific connection using its\nalias:\n\n```python\nfrom django.db import connections\n\nwith connections[\"my_db_alias\"].cursor() as cursor:\n    # Your code here\n    ...\n```\n\nBy default, the Python DB API will return results without their field names,\nwhich means you end up with a `list` of values, rather than a `dict`. At a\nsmall performance and memory cost, you can return results as a `dict` by\nusing something like this:\n\n```python\ndef dictfetchall(cursor):\n    \"\"\"\n    Return all rows from a cursor as a dict.\n    Assume the column names are unique.\n    \"\"\"\n    columns = [col[0] for col in cursor.description]\n    return [dict(zip(columns, row)) for row in cursor.fetchall()]\n```\n\nAnother option is to use [`collections.namedtuple()`](https://docs.python.org/3/library/collections.md#collections.namedtuple) from the Python\nstandard library. A `namedtuple` is a tuple-like object that has fields\naccessible by attribute lookup; it\u2019s also indexable and iterable. Results are\nimmutable and accessible by field names or indices, which might be useful:\n\n```python\nfrom collections import namedtuple\n\n\ndef namedtuplefetchall(cursor):\n    \"\"\"\n    Return all rows from a cursor as a namedtuple.\n    Assume the column names are unique.\n    \"\"\"\n    desc = cursor.description\n    nt_result = namedtuple(\"Result\", [col[0] for col in desc])\n    return [nt_result(*row) for row in cursor.fetchall()]\n```\n\nThe `dictfetchall()` and `namedtuplefetchall()` examples assume unique\ncolumn names, since a cursor cannot distinguish columns from different tables.\n\nHere is an example of the difference between the three:\n\n```python\n>>> cursor.execute(\"SELECT id, parent_id FROM test LIMIT 2\")\n>>> cursor.fetchall()\n((54360982, None), (54360880, None))\n\n>>> cursor.execute(\"SELECT id, parent_id FROM test LIMIT 2\")\n>>> dictfetchall(cursor)\n[{'parent_id': None, 'id': 54360982}, {'parent_id': None, 'id': 54360880}]\n\n>>> cursor.execute(\"SELECT id, parent_id FROM test LIMIT 2\")\n>>> results = namedtuplefetchall(cursor)\n>>> results\n[Result(id=54360982, parent_id=None), Result(id=54360880, parent_id=None)]\n>>> results[0].id\n54360982\n>>> results[0][0]\n54360982\n```\n\n### Connections and cursors\n\n`connection` and `cursor` mostly implement the standard Python DB-API\ndescribed in [**PEP 249**](https://peps.python.org/pep-0249/) \u2014 except when it comes to [transaction handling](transactions.md).\n\nIf you\u2019re not familiar with the Python DB-API, note that the SQL statement in\n`cursor.execute()` uses placeholders, `\"%s\"`, rather than adding\nparameters directly within t", "source_file_id": "django__5_2__topics__db__sql.html", "headings": ["Performing raw SQL queries", "Executing custom SQL directly"], "order": 7, "level": 2, "tokens": 938, "code_languages": ["python"], "links_out": [{"text": "`Manager.raw()`", "href": "#django.db.models.Manager.raw"}, {"text": "more than one database", "href": "multi-db.md"}, {"text": "`collections.namedtuple()`", "href": "https://docs.python.org/3/library/collections.md#collections.namedtuple"}], "id": "554e3294b42caedd", "char_count": 4556}
{"content": "or.execute(\"SELECT id, parent_id FROM test LIMIT 2\")\n>>> dictfetchall(cursor)\n[{'parent_id': None, 'id': 54360982}, {'parent_id': None, 'id': 54360880}]\n\n>>> cursor.execute(\"SELECT id, parent_id FROM test LIMIT 2\")\n>>> results = namedtuplefetchall(cursor)\n>>> results\n[Result(id=54360982, parent_id=None), Result(id=54360880, parent_id=None)]\n>>> results[0].id\n54360982\n>>> results[0][0]\n54360982\n```\n\n### Connections and cursors\n\n`connection` and `cursor` mostly implement the standard Python DB-API\ndescribed in [**PEP 249**](https://peps.python.org/pep-0249/) \u2014 except when it comes to [transaction handling](transactions.md).\n\nIf you\u2019re not familiar with the Python DB-API, note that the SQL statement in\n`cursor.execute()` uses placeholders, `\"%s\"`, rather than adding\nparameters directly within the SQL. If you use this technique, the underlying\ndatabase library will automatically escape your parameters as necessary.\n\nAlso note that Django expects the `\"%s\"` placeholder, *not* the `\"?\"`\nplaceholder, which is used by the SQLite Python bindings. This is for the sake\nof consistency and sanity.\n\nUsing a cursor as a context manager:\n\n```python\nwith connection.cursor() as c:\n    c.execute(...)\n```\n\nis equivalent to:\n\n```python\nc = connection.cursor()\ntry:\n    c.execute(...)\nfinally:\n    c.close()\n```\n\n#### Calling stored procedures\n\n`CursorWrapper.callproc(procname,params=None,kparams=None)`\n:   Calls a database stored procedure with the given name. A sequence\n    (`params`) or dictionary (`kparams`) of input parameters may be\n    provided. Most databases don\u2019t support `kparams`. Of Django\u2019s built-in\n    backends, only Oracle supports it.\n\n    For example, given this stored procedure in an Oracle database:\n\n    ```sql\n    CREATE PROCEDURE \"TEST_PROCEDURE\"(v_i INTEGER, v_text NVARCHAR2(10)) AS\n        p_i INTEGER;\n        p_text NVARCHAR2(10);\n    BEGIN\n        p_i := v_i;\n        p_text := v_text;\n        ...\n    END;\n    ```\n\n    This will call it:\n\n    ```python\n    with connection.cursor() as cursor:\n        cursor.callproc(\"test_procedure\", [1, \"test\"])\n    ```", "source_file_id": "django__5_2__topics__db__sql.html", "headings": ["Performing raw SQL queries", "Executing custom SQL directly", "Connections and cursors"], "order": 8, "level": 3, "tokens": 421, "code_languages": ["python"], "links_out": [{"text": "**PEP 249**", "href": "https://peps.python.org/pep-0249/"}, {"text": "transaction handling", "href": "transactions.md"}], "id": "2789cc5c43f520ae", "char_count": 2089}
